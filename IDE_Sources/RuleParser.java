/* Generated By:JavaCC: Do not edit this line. RuleParser.java */
import java.util.*;
import java.io.*;
import java.lang.*;

//==============================================================================
//==============================================================================
//==                                    ===****=====**=====**=====****==========
//==  JavaRETE/MORE                     ===*===*====*=*===*=*====*====*=========
//==  RuleParser source                 ===*===*====*==*=*==*=====**============
//==  (C) 2002 by Piotr M. Szczypinski  ===****=====*===*===*=======**==========
//==  NIST - Gaithersburg               ===*========*=======*====*====*=========
//==                                    ===*========*=======*=====****==========
//==============================================================================
//==============================================================================

// Parser class definition
public class RuleParser implements RuleParserConstants {
        public static void main(String args[]) throws ParseException, IOException
/*
	{
		System.out.println("TREE: ============================");
		RuleParser parser = new RuleParser(System.in);
		PrintTree(parser.StartTree(), 0);
	}
*/
        {
                System.out.println("\nPARSING WARNINGS: ============================");

                RuleParser parser = new RuleParser(System.in);
                parser.Start();

//		System.out.println("No. of rules: " + rules_count);
//		System.out.println("No. of conds: " + cond_blocks);
                System.out.println("\nPARSING RESULTS: =============================");

                System.out.println("\n----Conditions: reduced list --------------------");
                for(int i=0; i< reduced_list.size(); i++)
                        System.out.println((i+1)+"\t"+reduced_list.get(i).toString());


                System.out.println("\n----Variables\u0009 ------------------------------");
                for(int i=0; i< aliasname_list.size(); i++)
                        System.out.println((i+1) + "\t"+aliasname_list.get(i).toString());//+" -> "+alias_list.get(i).toString());

                System.out.println("\n----Conditions\u0009------------------------------");
                System.out.println("index of condition : object in token : -check or variable index");
                for(int i=0; i< tokensender_list.size(); i++)
                        System.out.println((i+1)+"\t"+tokensender_list.get(i).toString()
                                +"\t"+slot_list.get(i).toString());

                System.out.println("\n----objects sent------------------------------");
                for(int i=0; i< slot_list.size(); i++)
                        System.out.println((i+1)+"\t"+slot_list.get(i).toString());

/*
		System.out.println("\n----checks at token sent list-----------------");
		for(int i=0; i< anyalias_list.size(); i++)
			System.out.print(anyalias_list.get(i).toString()+"\t");
*/
                System.out.println("\n----Nodes\u0009\u0009 --------------------------------");
                for(int i=0; i< node_list.size(); i++)
                        System.out.println((i+1)+"\t"+node_list.get(i).toString());

                System.out.println("\n----Rules\u0009\u0009\u0009-------------------------------");
                for(int i=0; i< rule_list.size(); i++)
                        System.out.println((i+1)+"\t"+rule_list.get(i).toString());

                System.out.println("\n----RulesVIR\u0009 -------------------------------");
                for(int i=0; i< RulesVIR_List.size(); i++)
                {
                        System.out.print((i+1)+"\t");
                        ArrayList ar = (ArrayList)RulesVIR_List.get(i);
                        for(int j=0; j< ar.size(); j++)
                        {
                                System.out.print(" " + ar.get(j).toString());
                        }
                        System.out.println("");
                }

                System.out.println("\n----RulesCIR\u0009 -------------------------------");
                for(int i=0; i< RulesVIR_List.size(); i++)
                {
                        System.out.print((i+1)+"\t");
                        ArrayList ar = (ArrayList)RulesCIR_List.get(i);
                        for(int j=0; j< ar.size(); j++)
                        {
                                System.out.print(" " + ar.get(j).toString());
                        }
                        System.out.println("");
                }

                System.out.println("\n----Variables\u0009 ------------------------------");
                for(int i=0; i< aliasname_list.size(); i++)
                        System.out.println((i+1) + "\t"+aliasname_list.get(i).toString());//+" -> "+alias_list.get(i).toString());
                System.out.println("\n----Additional Variables ---------------------");
                for(int i=0; i< aliasnamd_list.size(); i++)
                        System.out.println((i+1) + "\t"+aliasnamd_list.get(i).toString());


                System.out.println("\n----MAKE list\u0009 ------------------------------");
                for(int i=0; i< MAKE_list.size(); i++)
                System.out.println((i+1) + "\t"+MAKE_list.get(i).toString());
                System.out.println("\n----MODIFY list ------------------------------");
                for(int i=0; i< MODIFY_list.size(); i++)
                System.out.println((i+1) + "\t"+MODIFY_list.get(i).toString());


/*

		System.out.println("\n----class_variables_list ---------------------");
		for(int i=0; i< class_variables_list.size(); i++)
		System.out.println((i+1) + "\t"+class_variables_list.get(i).toString());
		
		System.out.println("\n----classX_objects_list ---------------------");
		for(int i=0; i< classX_objects_list.size(); i++)
		System.out.println((i+1) + "\t"+classX_objects_list.get(i).toString());
		
		System.out.println("\n----class_objectsX_list ---------------------");
		for(int i=0; i< class_objectsX_list.size(); i++)
			System.out.println((i+1) + "\t"+class_objectsX_list.get(i).toString());
*/

                System.out.println("\n----------------------------------------------");

//		System.out.println(execute_code);



                System.out.println("\n\nCREATING CLASSES: ============================");
                CreateSourceFiles(null);
        }

//==============================================================================
        public static void PrintTree(ArrayList al, int tabs)
        {
                StringBuffer a = new StringBuffer("");
                int ss = al.size();
                for(int i = 0; i<tabs; i++) a.append(".");

                if(ss>0)
                {
                                System.out.println(a.toString() + al.get(0));
                                for(int i = 1; i < ss; i++) PrintTree((ArrayList)(al.get(i)), tabs+1);
                }
        }
//==============================================================================
        public static void PrintList(ArrayList al)
        {
                for(int i=0; i< al.size(); i++)
                        System.out.println((i+1)+"\t"+al.get(i).toString());
        }

/*
//==============================================================================
	public static ArrayList BuildTree(String input) throws ParseException, IOException
	{
		StringReader sr = new StringReader(input);
		RuleParser parser = new RuleParser(sr);
		return parser.StartTree();
	}
*/
//==============================================================================
        public static void ClearStaticVars()
        {
                noofobjects = 0;
                noofvariables = 0;
                noofchecks = 0;
                variabletype = 0;
                rules_count = 0;
                noofconditions = 0;
                maxnoofconditions = 0;
                meaobject = -1;
                alias_condition = true;
                anyalias_condition = false;
                slot_list = new ArrayList();
                class_variables_list = new ArrayList();
                classX_objects_list = new ArrayList();
                class_objectsX_list = new ArrayList();

                reduced_list = new ArrayList();
                tokensender_list = new ArrayList();
                node_list = new ArrayList();
                rulename_list = new ArrayList();
                rule_list = new ArrayList();
                rulemerit_list = new ArrayList();
                anyalias_list = new ArrayList();
                aliasname_list = new ArrayList();
                aliasnamd_list = new ArrayList();
                execute_code = new StringBuffer();
                object_list = new ArrayList();
                varvar_list = new ArrayList();
                idltree_list = new ArrayList();

                MAKE_list = new ArrayList();
                MODIFY_list = new ArrayList();
                RulesVIR_List = new ArrayList();
                VarsInRule_List = new ArrayList();
                RulesCIR_List = new ArrayList();
                CondsInRule_List = new ArrayList();
        }

        //==============================================================================
        ArrayList StartClasses(ArrayList al) throws ParseException
        {
                        if(al == null) class_variables_list = new ArrayList();
                        else class_variables_list = al;
                        return _StartClasses();
        }

//==============================================================================
//	public static void SaveClasses(String path) throws IOException
//	{
//		CreateCalsses(path);
//	}

//==============================================================================
        static public boolean modeDebug = false;

        static public boolean modeLEX = true;
        static public boolean modeMEA = false;
        static public boolean modeBC = false;
        static public boolean modeII = false;
        static public boolean modePEM = false;

        static public int temporary_writing_mode = 0;

        static public String modeServerArgs = "";

        static int nooftreerows = 0;
        static int noofobjects = 0;
        static int noofvariables = 0;
        static int noofchecks = 0;
        static int variabletype = 0; //0 - unknown, 1 - int, 2 - double, 4 - string, 8 - $variable

        static int rules_count = 0;
        static int noofconditions = 0;
        static int maxnoofconditions = 0;
        static int meaobject = -1;

//	static int cond_blocks = 0;
        static String object_name;
        static String current_rulename;

        static int variable_type = 0;
// alias_condition & anyalias_condition are egzamined in slot_opt()
// There is alias substitution { sth==$alias }
        static boolean alias_condition = true;
// There is any alias in the current expression { sth relation sth $alias sth }
        static boolean anyalias_condition = false;

// Current class and object
        static Token class_token, obj_token;

// String list of every relation (condition) statement { class:object:variable relation expression }
        static ArrayList slot_list = new ArrayList();

// String list of objects variables { class:variable }
        static ArrayList class_variables_list = new ArrayList();
        static ArrayList classX_objects_list = new ArrayList();
        static ArrayList class_objectsX_list = new ArrayList();


        static ArrayList reduced_list = new ArrayList();
        static ArrayList tokensender_list = new ArrayList();

// String list of every AND/OR node { operator input1 input2 }
        static ArrayList node_list = new ArrayList();
// String list of rule names { rulename }
        static ArrayList rulename_list = new ArrayList();
// String list of rule names with info on input { rulename:input }
        static ArrayList rule_list = new ArrayList();
        static ArrayList rulemerit_list = new ArrayList();

// Integer list of entries in slot_list where the aliases are substituted
// static ArrayList alias_list = new ArrayList();
// Integer list of entries in slot_list where the aliases are to check
        static ArrayList anyalias_list = new ArrayList();
// String list of alias names { $Rule_noAlias_name }
        static ArrayList aliasname_list = new ArrayList();


// String list of alias names { $Rule_noAlias_name }
        static ArrayList aliasnamd_list = new ArrayList();
        static StringBuffer execute_code = new StringBuffer();


// String list of objects. Rule local: cleared for every rule.
        static ArrayList object_list = new ArrayList();

// String list of objects. Rule local: cleared for every rule.
        static ArrayList varvar_list = new ArrayList();

// String list of tree items created according to IDL file.
        static ArrayList idltree_list = new ArrayList();

// String list of execute items for BC connections.
        static ArrayList MAKE_list = new ArrayList();
        static ArrayList MODIFY_list = new ArrayList();

// Lists of objects variables used in rules
        static ArrayList RulesVIR_List = new ArrayList();
        static ArrayList VarsInRule_List = new ArrayList();

        static ArrayList RulesCIR_List = new ArrayList();
        static ArrayList CondsInRule_List = new ArrayList();


        private static void InsertVariablesToClasses(String class_name, int variable_type, ArrayList nt, ArrayList at)
        {
                int c, atsize, i, k;
                ArrayList nn;

                c = -1;
                atsize = at.size();
                for(i = 0; i < atsize; i++)
                        if(((ArrayList)(at.get(i))).get(0).toString().compareTo(class_name) == 0) c = i;
                if(c<0)
                {
                        nn = new ArrayList();
                        nn.add(class_name);
                        c = at.size();
                        at.add(nn);
                }
                else nn = (ArrayList)(at.get(c));

                if(variable_type == 0)
                {
                        for(i = 0; i < nt.size(); i++)
                        {
                                boolean insert = true;
                                for(k = 1; k < nn.size(); k++)
                                {
                                        if               (((ArrayList)(nn.get(k))).get(0).toString().compareTo( "long "  + nt.get(i).toString() ) == 0) insert = false;
                                        else if(((ArrayList)(nn.get(k))).get(0).toString().compareTo(   "double " + nt.get(i).toString()        ) == 0) insert = false;
                                        else if(((ArrayList)(nn.get(k))).get(0).toString().compareTo(   "string " + nt.get(i).toString()        ) == 0) insert = false;
                                }
                                if(insert)
                                {
                                        ArrayList nnn = new ArrayList();
                                        nnn.add("string " + nt.get(i).toString());
                                        nn.add(nnn);
                                }
                        }
                }
                else if(variable_type == 1)
                {
                        for(i = 0; i < nt.size(); i++)
                        {
                                boolean insert = true;
                                for(k = 1; k < nn.size(); k++)
                                {
                                        if               (((ArrayList)(nn.get(k))).get(0).toString().compareTo( "long "  + nt.get(i).toString() ) == 0) insert = false;
                                        else if(((ArrayList)(nn.get(k))).get(0).toString().compareTo(   "double " + nt.get(i).toString()        ) == 0) insert = false;
                                        else if(((ArrayList)(nn.get(k))).get(0).toString().compareTo(   "string " + nt.get(i).toString()        ) == 0) insert = false;
                                }
                                if(insert)
                                {
                                        ArrayList nnn = new ArrayList();
                                        nnn.add("long " + nt.get(i).toString());
                                        nn.add(nnn);
                                }
                        }
                }
                else if(variable_type == 2)
                {
                        for(i = 0; i < nt.size(); i++)
                        {
                                boolean insert = true;
                                int subst = -1;

                                for(k = 1; k < nn.size(); k++)
                                {
                                        if               (((ArrayList)(nn.get(k))).get(0).toString().compareTo( "long "  + nt.get(i).toString() ) == 0) subst = k;
                                        else if(((ArrayList)(nn.get(k))).get(0).toString().compareTo(   "double " + nt.get(i).toString()        ) == 0) insert = false;
                                        else if(((ArrayList)(nn.get(k))).get(0).toString().compareTo(   "string " + nt.get(i).toString()        ) == 0) insert = false;

                                }
                                if(subst >= 0)
                                {
                                        ArrayList nnn = new ArrayList();
                                        nnn.add("double " + nt.get(i).toString());
                                        nn.set(subst, nnn);
                                }
                                else if(insert)
                                {
                                        ArrayList nnn = new ArrayList();
                                        nnn.add("double " + nt.get(i).toString());
                                        nn.add(nnn);
                                }
                        }
                }
                else
                {
                        for(i = 0; i < nt.size(); i++)
                        {
                                boolean insert = true;
                                int subst = -1;

                                for(k = 1; k < nn.size(); k++)
                                {
                                        if (((ArrayList)(nn.get(k))).get(0).toString().compareTo(       "long "  + nt.get(i).toString() ) == 0) subst = k;
                                        else if(((ArrayList)(nn.get(k))).get(0).toString().compareTo(   "double " + nt.get(i).toString()        ) == 0) subst = k;
                                        else if(((ArrayList)(nn.get(k))).get(0).toString().compareTo(   "string " + nt.get(i).toString()        ) == 0) insert = false;
                                }
                                if(subst >= 0)
                                {
                                        ArrayList nnn = new ArrayList();
                                        nnn.add("string " + nt.get(i).toString());
                                        nn.set(subst, nnn);
                                }
                                else if(insert)
                                {
                                        ArrayList nnn = new ArrayList();
                                        nnn.add("string " + nt.get(i).toString());
                                        nn.add(nnn);
                                }
                        }
                }
        }

//==============================================================================
// Creates Java source files for MORE network program
        public static void CreateSourceFiles(String path) throws IOException
        {
                boolean exclude = false;
                                String[] str;
                                File inputFile = new File("RuleParser.cc");
                                FileReader inputStream = new FileReader(inputFile);
                                BufferedReader input = new BufferedReader(inputStream, 1024);
                                String inputstring = new String();
                                File outputFile;
                                FileWriter out = null;

                                while((inputstring = input.readLine()) != null)
                                {
                                                if(inputstring.length()>=2)
                                                if(inputstring.charAt(0)=='#' && inputstring.charAt(1)=='#')
//						if(inputstring.substring(0, 1).compareTo("##")==0)
                                                {
                                                                str = inputstring.split(" ");

                                                                if(str[0].compareTo("##SaveTo")==0)
                                                                {
                                                                                if(out != null) out.close();

                                                                                if(path == null)outputFile = new File(str[1]);
                                                                                else outputFile = new File(path + str[1]);

                                                                                out = new FileWriter(outputFile);
                                                                                continue;
                                                                }

                                                                if(out != null)
                                                                {
// Writes sections dependent on inference network
                                                                                if(str[0].compareTo("##WriteTokenArrays")==0 && !exclude) WriteTokenArrays(out);
                                                                                else if(str[0].compareTo("##WriteTokenEvaluateFunction")==0 && !exclude) WriteTokenEvaluateFunction(out);
                                                                                else if(str[0].compareTo("##WriteNetworkNodes")==0 && !exclude) WriteNetworkNodes(out);
                                                                                else if(str[0].compareTo("##WriteNetworkConnections")==0 && !exclude) WriteNetworkConnections(out);
                                                                                else if(str[0].compareTo("##WriteFeedingSlots")==0 && !exclude) WriteFeedingSlots(out);
                                                                                else if(str[0].compareTo("##WriteUnFeedingSlots")==0 && !exclude) WriteUnFeedingSlots(out);
                                                                                else if(str[0].compareTo("##WriteExecutions")==0 && !exclude) WriteExecutions(out);
                                                                                else if(str[0].compareTo("##WriteDispatchExecution")==0 && !exclude) WriteDispatchExecution(out);
                                                                                else if(str[0].compareTo("##WriteStarter")==0 && !exclude) WriteStarter(out);
                                                                                else if(str[0].compareTo("##WriteConvertToAny")==0 && !exclude) WriteConvertToAny(out);
                                                                                else if(str[0].compareTo("##WriteConvertFromAny")==0 && !exclude) WriteConvertFromAny(out);
                                                                                else if(str[0].compareTo("##WriteSetTransparent")==0 && !exclude) WriteSetTransparent(out);
                                                                                else if(str[0].compareTo("##WriteBackwardChaining")==0 && !exclude) WriteBackwardChaining(out);
                                                                                else if(str[0].compareTo("##WriteParsingResults")==0 && !exclude) WriteParsingResults(out);
                                                                                else if(str[0].compareTo("##WriteServerArgs")==0 && !exclude) WriteServerArgs(out);
                                                                                else if(str[0].compareTo("##WriteNetworkConfiguration")==0 && !exclude)
                                                                                        {temporary_writing_mode = 0; WriteTreeConfiguration(out);}
                                                                                else if(str[0].compareTo("##WriteNetworkTree")==0 && !exclude)
                                                                                        {temporary_writing_mode = 1; WriteTreeConfiguration(out);}


// Copies section of RuleParser.cc
                                                                                else if(str[0].compareTo("##EndIf")==0) exclude = false;
                                                                                else if(str[0].compareTo("##Else")==0) {if(exclude) exclude = false; else exclude = true;}
// Copies section of RuleParser.cc
                                                                                else if(str[0].compareTo("##IfPEM")==0) {if(modePEM) exclude = false; else exclude = true;}

// Copies section of RuleParser.cc if in Forward Chaining mode
                                                                                else if(str[0].compareTo("##IfLEX")==0) {if(modeLEX) exclude = false; else exclude = true;}
                                                                                else if(str[0].compareTo("##IfMEA")==0) {if(modeMEA) exclude = false; else exclude = true;}
// Copies section of RuleParser.cc if in Backward Chaining mode
                                                                                else if(str[0].compareTo("##IfBC")==0) {if(modeBC) exclude = false; else exclude = true;}
// Copies section of RuleParser.cc if Inexact Inferencing on
                                                                                else if(str[0].compareTo("##IfII")==0) {if(modeII) exclude = false; else exclude = true;}

                                                                                else if(str[0].compareTo("##IfDebug")==0) {if(modeDebug) exclude = false; else exclude = true;}
                                                                                continue;
                                                                }
                                                                continue;
                                                }
// Copies regular sections independent from rules
                                                if((out != null) && (!exclude))
                                                {
                                                                out.write(inputstring, 0, inputstring.length());
                                                                out.write("\n", 0, 1);
                                                }
                                }
                                inputStream.close();
                                input.close();
                                if(out != null) out.close();
                }



        public static void WriteParsingResults(FileWriter out) throws IOException
        {
                out.write("\n----Conditions: reduced list --------------------\n");
                out.write("// Unique conditions (may be multiplied in different rules)\n");
                out.write("// index\tobject:variable_name:relation:expression\n");
                for(int i=0; i< reduced_list.size(); i++)
                        out.write((i+1)+"\t"+reduced_list.get(i).toString()+ "\n");

                out.write("\n----Variables    ------------------------------\n");
                out.write("// Variables used in LHS of rule\n");
                out.write("// index\t&rule_no&variable_name\n");
                for(int i=0; i< aliasname_list.size(); i++)
                        out.write((i+1) + "\t"+aliasname_list.get(i).toString()+ "\n");//+" -> "+alias_list.get(i).toString());

                out.write("\n----Additional Variables ---------------------\n");
                out.write("// Variables used only in RHS of rule\n");
                out.write("// index\t&rule_no&variable_name\n");
                for(int i=0; i< aliasnamd_list.size(); i++)
                        out.write((i+1) + "\t"+aliasnamd_list.get(i).toString()+ "\n");

                out.write("\n----Conditions  ------------------------------\n");
                out.write("// List of all conditions\n");
                out.write("// index of condition : object in token : -check or variable index\n");
                for(int i=0; i< tokensender_list.size(); i++)
                        out.write((i+1)+"\t"+tokensender_list.get(i).toString()
                                +"\t"+slot_list.get(i).toString()+ "\n");

                out.write("\n----objects sent------------------------------\n");
                for(int i=0; i< slot_list.size(); i++)
                        out.write((i+1)+"\t"+slot_list.get(i).toString()+ "\n");

/*
		out.write("\n----checks at token sent list-----------------");
		for(int i=0; i< anyalias_list.size(); i++)
			out.write(anyalias_list.get(i).toString()+"\t");
*/
                out.write("\n----Nodes     --------------------------------\n");
                for(int i=0; i< node_list.size(); i++)
                        out.write((i+1)+"\t"+node_list.get(i).toString()+ "\n");

                out.write("\n----Rules      -------------------------------\n");
                for(int i=0; i< rule_list.size(); i++)
                        out.write((i+1)+"\t"+((Integer)rulemerit_list.get(i)).intValue()+"\t"+rule_list.get(i).toString()+ "\n");

                out.write("\n----RulesVIR   -------------------------------\n");
                out.write("// Dependencies between rules and variables (used in backward chaining)\n");
                for(int i=0; i< RulesVIR_List.size(); i++)
                {
                        out.write((i+1)+"\t");
                        ArrayList ar = (ArrayList)RulesVIR_List.get(i);
                        for(int j=0; j< ar.size(); j++)
                        {
                                out.write(" " + ar.get(j).toString());
                        }
                        out.write("\n");
                }
                out.write("\n----RulesCIR   -------------------------------\n");
                out.write("// Dependencies between rules and entries in MODIFY list\n");
                for(int i=0; i< RulesVIR_List.size(); i++)
                {
                        out.write((i+1)+"\t");
                        ArrayList ar = (ArrayList)RulesCIR_List.get(i);
                        for(int j=0; j< ar.size(); j++)
                        {
                                out.write(" " + ar.get(j).toString());
                        }
                        out.write("\n");
                }

                out.write("\n----MAKE list   ------------------------------\n");
                for(int i=0; i< MAKE_list.size(); i++)
                out.write((i+1) + "\t"+MAKE_list.get(i).toString()+ "\n");
                out.write("\n----MODIFY list ------------------------------\n");
                for(int i=0; i< MODIFY_list.size(); i++)
                out.write((i+1) + "\t"+MODIFY_list.get(i).toString()+ "\n");
        }

        public static void WriteServerArgs(FileWriter out) throws IOException
        {
                boolean first = true;
                String str[] = modeServerArgs.split(" ");

                out.write("\t\tpublic static String[] servargs = {");
                for(int i=0; i<str.length; i++)
                {
                        if(first)
                        {
                                if(str[i].length()>0) out.write("\"" +str[i]+ "\"");
                                first = false;
                        }
                        else
                        {
                                if(str[i].length()>0) out.write(", \"" +str[i]+ "\"");
                        }
                }
                out.write("};\n");
        }

        public static void WriteTreeConfigurationWrite(FileWriter out, String mom, int mom_index, String kid, int kid_index, int tabs) throws IOException
        {
                String outputstring = new String();
                if(temporary_writing_mode == 0)
                {
                        WriteTabs(out, tabs);
                        outputstring = "[" + mom_index + "]" + mom + " -> " + "[" + kid_index + "]" + kid + "\n";
                        out.write(outputstring, 0, outputstring.length());
                }
                else
                {
                        WriteTabs(out, tabs);
                        outputstring = "javax.swing.tree.DefaultMutableTreeNode treeNode_"
                                + kid_index + " = new javax.swing.tree.DefaultMutableTreeNode(" + kid + ");\n";
                        out.write(outputstring, 0, outputstring.length());
                        WriteTabs(out, tabs);
                        outputstring = "treeNode_" + mom_index + ".add(treeNode_" + kid_index + ");\n";
                        out.write(outputstring, 0, outputstring.length());
                }
        }

        public static void WriteTreeConfigurationBranch(FileWriter out, String node_name, int inp, String mom, int mom_index, int tabs) throws IOException
        {
                if(inp > 0)
                {
//Only one condition in rule
                        String[] strc = tokensender_list.get(inp-1).toString().split(":");
                        Integer iic = new Integer(strc[0]);
                        nooftreerows++;
                        WriteTreeConfigurationWrite(out, mom, mom_index, "Condition" + iic.intValue(), nooftreerows, tabs);
                }
                else
                {
//Go up to the main node in rule
                        String kid;
                        if(node_name.compareTo("OR")==0)
                                kid = "Or" + (-inp);
                        else
                                kid = "And" + (-inp);

                        nooftreerows++;
                        WriteTreeConfigurationWrite(out, mom, mom_index, kid, nooftreerows, tabs);
                        WriteTreeConfigurationNode(out, kid, nooftreerows, -inp-1, tabs+1);
                }
        }

        public static void WriteTreeConfigurationNode(FileWriter out, String mom, int mom_index, int node, int tabs) throws IOException
        {
                String outputstring = new String();
                String[] str = node_list.get(node).toString().split(" ");
                for(int k=1; k<=2; k++)
                {
                        int inp = (new Integer(str[k])).intValue();
                        WriteTreeConfigurationBranch(out, str[0], inp, mom, mom_index, tabs);
                }
        }

        public static void WriteTreeConfigurationRule(FileWriter out, int rule, int tabs) throws IOException
        {
                String outputstring = new String();
                String[] str;
                int inp;

                str = rule_list.get(rule).toString().split(":");
                Integer integer = new Integer(str[1]);
                inp = integer.intValue();
                String kid = "Rule" + (rule+1) + "_" + str[0];

                if(inp<=0) str = node_list.get(-inp-1).toString().split(" ");
                nooftreerows++;
                WriteTreeConfigurationWrite(out, "root", 0, kid, nooftreerows, tabs);
                WriteTreeConfigurationBranch(out, str[0], inp, kid, nooftreerows, tabs);
        }

        public static void WriteTreeConfiguration(FileWriter out) throws IOException
        {
                nooftreerows=0;
                String outputstring = new String();
                for(rules_count=rule_list.size()-1; rules_count>=0; rules_count--)
                {
                        out.write("\n", 0, 1);
                        WriteTreeConfigurationRule(out, rules_count, 2);
                }
        }

        public static void WriteTabs(FileWriter out, int tabs) throws IOException
        {
                for(int i=0; i<tabs; i++ ) out.write("\t", 0, 1);
        }

        public static void WriteBackwardChainingCondition(FileWriter out, boolean[] rules, boolean[] opened, int cond, int tabs) throws IOException
        {
                if(opened[cond]) return;

                String outputstring = new String();
                String variable;
                String[] sy;
                String[] st;

                WriteTabs(out, tabs);
                outputstring = "Condition"+ (cond+1) + ".SetTransparent();\n";
                out.write(outputstring, 0, outputstring.length());
                sy = reduced_list.get(cond).toString().split(":");

                opened[cond] = true;

                for(int m=0; m< MAKE_list.size(); m++)
                {
                        st = MAKE_list.get(m).toString().split(":");
                        if(st[0].compareTo(sy[0]) == 0)
                        {
                                st = MAKE_list.get(m).toString().split(" ");
                                WriteBackwardChainingRule(out, rules, opened, (new Integer(st[1])).intValue(), tabs);
                        }
                }

                variable = sy[0]+":"+sy[1];
                for(int m=0; m< MODIFY_list.size(); m++)
                {
                        st = MODIFY_list.get(m).toString().split(" ");
                        if(st[0].compareTo(variable) == 0)
                        {
                                WriteBackwardChainingRule(out, rules, opened, (new Integer(st[1])).intValue(), tabs);
                        }
                }

/*
		variable = sy[0]+":"+sy[1];
		st = MODIFY_list.get(0).toString().split(" ");
		if(st[0].compareTo(variable) == 0)
		{
			WriteBackwardChainingRule(out, rules, opened, (new Integer(st[1])).intValue(), tabs);
		}
		boolean[] openedn = new boolean[reduced_list.size()];
		for(int i=reduced_list.size()-1; i>=0; i--) openedn[i] = opened[i];

		for(int m=1; m< MODIFY_list.size(); m++)
		{
			st = MODIFY_list.get(m).toString().split(" ");
			if(st[0].compareTo(variable) == 0)
			{
				WriteBackwardChainingRule(out, rules, openedn, (new Integer(st[1])).intValue(), tabs);
			}
		}
*/
        }

        public static void WriteBackwardChainingNode(FileWriter out, boolean[] rules, boolean[] opened, int node, int tabs) throws IOException
        {
                String outputstring = new String();
                String[] str;

                str = node_list.get(node).toString().split(" ");
                Integer i1 = new Integer(str[1]);
                Integer i2 = new Integer(str[2]);

                if(str[0].compareTo("OR")==0)
                {
                        WriteTabs(out, tabs);
                        outputstring = "//NodeOR_"+ (node+1) + "\n";
                        out.write(outputstring, 0, outputstring.length());

                        if(i1.intValue() > 0)
                        {
//Connected to condition
                                String[] strc = tokensender_list.get(i1.intValue()-1).toString().split(":");
                                Integer iic = new Integer(strc[0]);
                                WriteTabs(out, tabs+1);
                                outputstring = "//O_OpenCondition_"+ (iic.intValue()) + "\n";
                                out.write(outputstring, 0, outputstring.length());
                                WriteBackwardChainingCondition(out, rules, opened, iic.intValue()-1, tabs+1);
                        }
                        else
                        {
//Go up to the main node in rule
                                WriteBackwardChainingNode(out, rules, opened, -i1.intValue()-1, tabs+1);
                        }
                        WriteTabs(out, tabs);
                        outputstring = "if(Or" + (node+1) + ".GetToken() <= 0)\n";
                        out.write(outputstring, 0, outputstring.length());
                        WriteTabs(out, tabs);
                        outputstring = "{\n";
                        out.write(outputstring, 0, outputstring.length());

                        boolean[] openedn = new boolean[reduced_list.size()];
                        for(int i=reduced_list.size()-1; i>=0; i--) openedn[i] = opened[i];

                        if(i2.intValue() > 0)
                        {
//Connected to condition
                                String[] strc = tokensender_list.get(i2.intValue()-1).toString().split(":");
                                Integer iic = new Integer(strc[0]);
                                WriteTabs(out, tabs+1);
                                outputstring = "//O_OpenCondition_"+ (iic.intValue()) + "\n";
                                out.write(outputstring, 0, outputstring.length());
                                WriteBackwardChainingCondition(out, rules, openedn, iic.intValue()-1, tabs+1);
                        }
                        else
                        {
//Go up to the main node in rule
                                WriteBackwardChainingNode(out, rules, openedn, -i2.intValue()-1, tabs+1);
                        }
                        WriteTabs(out, tabs);
                        outputstring = "}\n";
                        out.write(outputstring, 0, outputstring.length());
                }
                else
                {
                        WriteTabs(out, tabs);
                        outputstring = "//NodeAND_"+ (node+1) + "\n";
                        out.write(outputstring, 0, outputstring.length());

                        if(i1.intValue() > 0)
                        {
//Connected to condition
                                String[] strc = tokensender_list.get(i1.intValue()-1).toString().split(":");
                                Integer iic = new Integer(strc[0]);
                                WriteTabs(out, tabs+1);
                                outputstring = "//A_OpenCondition_"+ (iic.intValue()) + "\n";
                                out.write(outputstring, 0, outputstring.length());
                                WriteBackwardChainingCondition(out, rules, opened, iic.intValue()-1, tabs+1);
                        }
                        else
                        {
//Go up to the main node in rule
                                WriteBackwardChainingNode(out, rules, opened, -i1.intValue()-1, tabs);
                        }
                        if(i2.intValue() > 0)
                        {
//Connected to condition
                                String[] strc = tokensender_list.get(i2.intValue()-1).toString().split(":");
                                Integer iic = new Integer(strc[0]);
                                WriteTabs(out, tabs+1);
                                outputstring = "//A_OpenCondition_"+ (iic.intValue()) + "\n";
                                out.write(outputstring, 0, outputstring.length());
                                WriteBackwardChainingCondition(out, rules, opened, iic.intValue()-1, tabs+1);
                        }
                        else
                        {
//Go up to the main node in rule
                                WriteBackwardChainingNode(out, rules, opened, -i2.intValue()-1, tabs);
                        }
                }
        }

        public static void WriteBackwardChainingRule(FileWriter out, boolean[] rules, boolean[] opened, int rule, int tabs) throws IOException
        {
                String outputstring = new String();
                if(rules[rule])
                {
                        rules[rule] = false;
                        WriteTabs(out, tabs);
                        outputstring = "//EnteringRule_"+ (rule+1) + "\n";
                        out.write(outputstring, 0, outputstring.length());

                        String[] str, st;
                        int inp;

                        str = rule_list.get(rule).toString().split(":");
                        Integer integer = new Integer(str[1]);
                        inp = integer.intValue();

                        if(inp > 0)
                        {
//Only one condition in rule
                                String[] strc = tokensender_list.get(inp-1).toString().split(":");
                                Integer iic = new Integer(strc[0]);
                                WriteTabs(out, tabs+1);
                                outputstring = "//R_OpenCondition_"+ (iic.intValue()) + "\n";
                                out.write(outputstring, 0, outputstring.length());
                                WriteBackwardChainingCondition(out, rules, opened, iic.intValue()-1, tabs);
                        }
                        else
                        {
//Go up to the main node in rule
                                WriteBackwardChainingNode(out, rules, opened, -inp-1, tabs);
                        }
                        WriteTabs(out, tabs);
                        outputstring = "//ExecutingRule_"+ (rule+1) + "\n";
                        out.write(outputstring, 0, outputstring.length());

                        WriteTabs(out, tabs);
                        outputstring = "frl = ReteConflictSet.GetFiredOfMerit("+ ((Integer)rulemerit_list.get(rule)).intValue()+");\n";
                        out.write(outputstring, 0, outputstring.length());

                        if(modeDebug)
                        {
                                outputstring = "System.out.println(\"Executing_rule_"+ (rule+1) +"_merit_"+
                                        ((Integer)rulemerit_list.get(rule)).intValue()+" _with_\" + frl.size() + \"_tokens\");\n";
                                out.write(outputstring, 0, outputstring.length());
                        }

                        WriteTabs(out, tabs);
                        outputstring = "for(int i = 0; i < frl.size(); i++)\n";
                        out.write(outputstring, 0, outputstring.length());
                        WriteTabs(out, tabs);
                        outputstring = "\texecutions.ExecuteRule((ReteToken)frl.get(i));\n";
                        out.write(outputstring, 0, outputstring.length());

                        if(modeDebug)
                        {
                                outputstring = "System.out.println(\"Rule_executed_"+ (rule+1) +"_merit_"+ (
                                        (Integer)rulemerit_list.get(rule)).intValue() +"\");\n";
                                out.write(outputstring, 0, outputstring.length());
                        }
                }
        }

// Saves Backward chaining sequence
        public static void WriteBackwardChaining(FileWriter out) throws IOException
        {
                String outputstring = new String();

                boolean[] rules = new boolean[rule_list.size()];
                for(int i=rule_list.size()-1; i>=0; i--) rules[i] = true;

                boolean[] opened = new boolean[reduced_list.size()];
                for(int i=reduced_list.size()-1; i>=0; i--) opened[i] = false;

                outputstring = "\t\tArrayList frl;\n";
                out.write(outputstring, 0, outputstring.length());

                outputstring = "\t\tReteConflictSet.BackwardMode("+ rule_list.size() +");\n";
                out.write(outputstring, 0, outputstring.length());

                for(rules_count=rule_list.size()-1; rules_count>=0; rules_count--)
                {
                        outputstring = "\t\t//Fresh rule #["+(rules_count+1)+"]\n";
                        out.write(outputstring, 0, outputstring.length());
                        WriteBackwardChainingRule(out, rules, opened, rules_count, 2);
                }
        }


// Saves nodes definitions
        public static void WriteNetworkNodes(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String[] str;

                outputstring = "\n\n//----------------- Rule nodes -----------------";
                out.write(outputstring, 0, outputstring.length());

                for(int i=0; i< rule_list.size(); i++)
                {
                        str = rule_list.get(i).toString().split(":");
                        outputstring = "\n\t\tReteNodeFinal Rule" + (i+1) + "_" + str[0] +" = new ReteNodeFinal(\"Rule" + (i+1) + "_" + str[0] +"\", "+
                                + ((Integer)rulemerit_list.get(i)).intValue()+ ", " +str[4] +");";
                        out.write(outputstring, 0, outputstring.length());
                }

                outputstring = "\n\n//----------------- Condition nodes -----------------";
                out.write(outputstring, 0, outputstring.length());

                for(int i=0; i< reduced_list.size(); i++)
                {
//			str = reduced_list.get(i).toString().split(":");
                        String relation = new String(reduced_list.get(i).toString());
                        relation = relation.replaceFirst(":", ".");
                        relation = relation.replaceAll(":", " ");
                        relation = relation.replaceAll("\"", "\\\\\"");

                        outputstring = "\n\t\tReteNodeCondition Condition"+ (i+1) +" = new ReteNodeCondition(\"C"+ (i+1) + ": " + relation + "\");";
                        out.write(outputstring, 0, outputstring.length());
                }

                outputstring = "\n\n//----------------- Logic nodes -----------------";
                out.write(outputstring, 0, outputstring.length());

                for(int i=0; i< node_list.size(); i++)
                {
                        str = node_list.get(i).toString().split(" ");

                        if(str[0].compareTo("OR")==0)
                                outputstring = "\n\t\tReteNodeOR Or"+ (i+1) +" = new ReteNodeOR(\"Or"+ (i+1) + "\");";
                        else
                                outputstring = "\n\t\tReteNodeAND And"+ (i+1) +" = new ReteNodeAND(\"And"+ (i+1) + "\");";

                        out.write(outputstring, 0, outputstring.length());
                }
                out.write("\n", 0, 1);
        }

// Sets all condition nodes as transparent, to imediately send token forward.
        public static void WriteSetTransparent(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String[] str;

                for(int i=0; i< reduced_list.size(); i++)
                {
                        str = reduced_list.get(i).toString().split(":");

                        outputstring = "\n\t\tCondition"+ (i+1) +".SetTransparent();";
                        out.write(outputstring, 0, outputstring.length());
                }
                out.write("\n", 0, 1);
        }

// Saves connectivity
        public static void WriteNetworkConnections(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String[] str, st;
                int inp;

                outputstring = "\n\n//----------------- Connections -----------------";
                out.write(outputstring, 0, outputstring.length());

                for(int i=0; i< rule_list.size(); i++)
                {
                        str = rule_list.get(i).toString().split(":");

                        Integer integer = new Integer(str[1]);
                        inp = integer.intValue();

// Rules
                        if(inp > 0)
                        {
                                String[] strc = tokensender_list.get(inp-1).toString().split(":");
                                Integer iic = new Integer(strc[0]);

                                outputstring = "\n\t\tRule" + (i+1) + "_" + str[0] +
                                                                                         ".SetInputNode( Condition"+ (iic.intValue()) + " );\n" +
                                                                                         "\t\tCondition" + (iic.intValue()) + ".SetOutputNode( Rule" +
                                                                 (i+1) + "_" + str[0] + " );";
                        }
                        else
                        {
                                st = node_list.get(-inp-1).toString().split(" ");
                                if(st[0].compareTo("OR") == 0)
                                {
                                        outputstring = "\n\t\tRule" + (i+1) + "_" + str[0] +
                                                                                         ".SetInputNode( Or"+ (-inp) + " );\n" +
                                                                                         "\t\tOr" + (-inp) + ".SetOutputNode( Rule" +
                                                                 (i+1) + "_" + str[0] + " );";
                                }

                                else
                                {
                                        outputstring = "\n\t\tRule" + (i+1) + "_" + str[0] +
                                                                                         ".SetInputNode( And"+ (-inp) + " );\n" +
                                                                                         "\t\tAnd" + (-inp) + ".SetOutputNode( Rule" +
                                                                 (i+1) + "_" + str[0] + " );";
                                }
                        }
                        out.write(outputstring, 0, outputstring.length());
                }

                out.write("\n", 0, 1);

// AND OR
                for(int i=0; i< node_list.size(); i++)
                {
                        str = node_list.get(i).toString().split(" ");
                        Integer integer = new Integer(str[1]);
                        inp = integer.intValue();

                        if(inp > 0)
                        {
                                String[] strc = tokensender_list.get(inp-1).toString().split(":");
                                Integer iic = new Integer(strc[0]);

                                if(str[0].compareTo("OR")==0)
                                {
                                        outputstring = "\n\t\tOr" + (i+1) + ".SetInputNode( Condition"+ (iic.intValue()) + " );" +
                                                                                         "\n\t\tCondition" + (iic.intValue()) + ".SetOutputNode( Or" + (i+1) + " );";
                                }

                                else
                                {
                                        outputstring = "\n\t\tAnd" + (i+1) + ".SetInputNode( Condition"+ (iic.intValue()) + " );" +
                                                                                         "\n\t\tCondition" + (iic.intValue()) + ".SetOutputNode( And" + (i+1) + " );";
                                }
                        }

                        else
                        {
                                st = node_list.get(-inp-1).toString().split(" ");

                                if(str[0].compareTo("OR")==0)
                                {
                                        if(st[0].compareTo("OR")==0)
                                        {
                                                outputstring = "\n\t\tOr" + (i+1) + ".SetInputNode( Or"+ (-inp) + " );" +
                                                                                                 "\n\t\tOr" + (-inp) + ".SetOutputNode( Or" + (i+1) + " );";
                                        }

                                        else
                                        {
                                                outputstring = "\n\t\tOr" + (i+1) + ".SetInputNode( And"+ (-inp) + " );" +
                                                                                                 "\n\t\tAnd" + (-inp) + ".SetOutputNode( Or" + (i+1) + " );";
                                        }
                                }

                                else
                                {
                                        if(st[0].compareTo("OR")==0)
                                        {
                                                outputstring = "\n\t\tAnd" + (i+1) + ".SetInputNode( Or"+ (-inp) + " );" +
                                                                                                 "\n\t\tOr" + (-inp) + ".SetOutputNode( And" + (i+1) + " );";
                                        }

                                        else
                                        {
                                                outputstring = "\n\t\tAnd" + (i+1) + ".SetInputNode( And"+ (-inp) + " );" +
                                                                                                 "\n\t\tAnd" + (-inp) + ".SetOutputNode( And" + (i+1) + " );";
                                        }
                                }
                        }
                        out.write(outputstring, 0, outputstring.length());

                        integer = new Integer(str[2]);
                        inp = integer.intValue();

                        if(inp > 0)
                        {

                                String[] strc = tokensender_list.get(inp-1).toString().split(":");
                                Integer iic = new Integer(strc[0]);

                                if(str[0].compareTo("OR")==0)
                                {
                                        outputstring = "\n\t\tOr" + (i+1) + ".SetInputNode( Condition"+ (iic.intValue()) + " );" +
                                                                                         "\n\t\tCondition" + (iic.intValue()) + ".SetOutputNode( Or" + (i+1) + " );";
                                }

                                else
                                {
                                        outputstring = "\n\t\tAnd" + (i+1) + ".SetInputNode( Condition"+ (iic.intValue()) + " );" +
                                                                                         "\n\t\tCondition" + (iic.intValue()) + ".SetOutputNode( And" + (i+1) + " );";
                                }
                        }

                        else
                        {
                                st = node_list.get(-inp-1).toString().split(" ");

                                if(str[0].compareTo("OR")==0)
                                {
                                        if(st[0].compareTo("OR")==0)
                                        {
                                                outputstring = "\n\t\tOr" + (i+1) + ".SetInputNode( Or"+ (-inp) + " );" +
                                                                                                 "\n\t\tOr" + (-inp) + ".SetOutputNode( Or" + (i+1) + " );";
                                        }

                                        else
                                        {
                                                outputstring = "\n\t\tOr" + (i+1) + ".SetInputNode( And"+ (-inp) + " );" +
                                                                                                 "\n\t\tAnd" + (-inp) + ".SetOutputNode( Or" + (i+1) + " );";
                                        }
                                }

                                else
                                {
                                        if(st[0].compareTo("OR")==0)
                                        {
                                                outputstring = "\n\t\tAnd" + (i+1) + ".SetInputNode( Or"+ (-inp) + " );" +
                                                                                                 "\n\t\tOr" + (-inp) + ".SetOutputNode( And" + (i+1) + " );";
                                        }

                                        else
                                        {
                                                outputstring = "\n\t\tAnd" + (i+1) + ".SetInputNode( And"+ (-inp) + " );" +
                                                                                                 "\n\t\tAnd" + (-inp) + ".SetOutputNode( And" + (i+1) + " );";
                                        }
                                }
                        }
                        out.write(outputstring, 0, outputstring.length());
                }
                out.write("\n", 0, 1);
        }

// Saves token arrays
        public static void WriteExecutions(FileWriter out) throws IOException
        {
                out.write(execute_code.toString(), 0, execute_code.length());
                out.write("\t}\n", 0, 3);
        }

        public static void WriteDispatchExecution(FileWriter out) throws IOException
        {
                String[] str;
                String outputstring = new String();

                for(int i=0; i< rulename_list.size(); i++)
                {
                        str = rule_list.get(i).toString().split(":");

//			outputstring = "\t\tcase " +(i+1)+ ": Execute_"+ str[0] +"(token); break;\n";
                        outputstring = "\t\tcase " +((Integer)rulemerit_list.get(i)).intValue()+ ": Execute_"+ str[0] +"(token); break;\n";
                        out.write(outputstring, 0, outputstring.length());
                }
        }

        public static void WriteStarter(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String[] sto;
                int k = 0;
                for(int i=0; i< reduced_list.size(); i++)
                {
                        sto = reduced_list.get(i).toString().split(":");
                        if(sto[0].compareTo("COSMOS_START") == 0) k++;
                }
                if(k>0)
                {
                        outputstring = "\t\tCOSMOS_START __starter = new COSMOS_START();\n";
                        out.write(outputstring, 0, outputstring.length());
                        outputstring = "\t\t__starter.init_status = 1;\n\t\tMemSetObject(__starter, \"__starter\");\n";
                        out.write(outputstring, 0, outputstring.length());
                }
                else
                {
                        outputstring = "\t\tif(wmserverinterface!=null)\u0009LoadObjectsFromWM(false);\n";
                        out.write(outputstring, 0, outputstring.length());
                }
        }

// Saves token arrays
        public static void WriteTokenArrays(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String str = new String();
//		String[] str;

                outputstring = "\n//----------------- Token array sizes -----------------";
                out.write(outputstring, 0, outputstring.length());

                outputstring = "\n\tstatic final int objectsno = " + noofobjects +";";//##NoOfObjects
                out.write(outputstring, 0, outputstring.length());

                outputstring = "\n\tstatic final int variablesno = " + aliasname_list.size() +";";//##NoOfVariables
                out.write(outputstring, 0, outputstring.length());

                outputstring = "\n\tstatic final int checksno = " + anyalias_list.size() +";";//##NoOfChecks
                out.write(outputstring, 0, outputstring.length());

/*
		outputstring = "\n\n//----------------- Token arrays -----------------";
		out.write(outputstring, 0, outputstring.length());

		outputstring = "\n\tstatic final String[] variablenm =\n\t{";
		out.write(outputstring, 0, outputstring.length());

		for(int i=0; i<aliasname_list.size()-1; i++)
		{
			outputstring = "\n\t\t\"" + aliasname_list.get(i).toString().trim() + "\",";
			out.write(outputstring, 0, outputstring.length());
		}
		if(aliasname_list.size()>0)
		{
			outputstring = "\n\t\t\"" + aliasname_list.get(aliasname_list.size()-1).toString().trim() + "\"\n";
			out.write(outputstring, 0, outputstring.length());
		}
		outputstring = "\t};"
		out.write(outputstring, 0, outputstring.length());
*/
/*
		outputstring = "\n\tstatic final String[] checknm =\n\t{";
		out.write(outputstring, 0, outputstring.length());

		for(int i=0; i<anyalias_list.size()-1; i++)
		{
			str = reduced_list.get(((Integer)anyalias_list.get(i)).intValue()).toString();

			outputstring = "\n\t\t\"" + str + "\",";
			out.write(outputstring, 0, outputstring.length());
		}
		outputstring = "\n\t\t\"" +
			reduced_list.get(((Integer)anyalias_list.get(anyalias_list.size()-1)).intValue()).toString()
			+ "\"\n\t}";
		out.write(outputstring, 0, outputstring.length());
*/
                out.write("\n", 0, 1);
        }


// Saves token arrays
        public static void WriteTokenEvaluateFunction(FileWriter out) throws IOException
        {
                String outputstring = new String();
                boolean[] vars = new boolean[aliasname_list.size()];

//		MAKE_list = new ArrayList();

                outputstring = "\n//----------------- Evaluate function -----------------";
                out.write(outputstring, 0, outputstring.length());

                for(int i=0; i<anyalias_list.size(); i++)
                {
                        boolean dostring = true;
                        StringBuffer sb = new StringBuffer();
                        String[] str, st;

                        str = reduced_list.get(((Integer)anyalias_list.get(i)).intValue()-1).toString().split(":");
                        st = str[3].split(" ");

/*//PMS 
			if(modeII)
			{
				ArrayList temp_list = new ArrayList();
				for(int k = 0; k<st.length; k++)
				{
					String ss = " " + st[k] + " ";
					int ind = aliasname_list.indexOf(ss);
					if(ind >= 0)
					{
						Integer iind = new Integer(ind);
						if(!temp_list.contains(iind)) temp_list.add(iind);
					}
				}
				outputstring = "\n\tprivate static int VarsInCheck"+ i +"[] = {";
				out.write(outputstring, 0, outputstring.length());
				for(int k = 0; k < temp_list.size(); k++)
				{
					if(k == temp_list.size()-1)
					{
						outputstring = temp_list.get(k).toString();
						out.write(outputstring, 0, outputstring.length());
					}
					else
					{
						outputstring = temp_list.get(k).toString()+", ";
						out.write(outputstring, 0, outputstring.length());
					}
				}
				outputstring = "};\n";
				out.write(outputstring, 0, outputstring.length());
			}
*/
                        outputstring = "\n\tprivate static boolean Evaluate"+ i +"(Integer var, ReteToken token)\n\t{\n";
                        out.write(outputstring, 0, outputstring.length());

                        outputstring = "\t\tif(var == null) return false;\n";
                        out.write(outputstring, 0, outputstring.length());

                        outputstring = "\t\tif(var.doubleValue() " + str[2] + " ";
                        out.write(outputstring, 0, outputstring.length());

                        for(int k = 0; k<st.length; k++)
                        {
                                String ss = " " + st[k] + " ";
                                int ind = aliasname_list.indexOf(ss);

                                if(ind >= 0)
                                {
                                        outputstring = "((Number)(token.variable[" + ind + "])).doubleValue()";
                                        out.write(outputstring, 0, outputstring.length());
                                }
                                else
                                {
                                        if(st[k].length() > 0 && st[k].compareTo("+") != 0)
                                                dostring = false;
                                        out.write(st[k], 0, st[k].length());
                                }
                        }
                        outputstring = ") return true;\n\t\treturn false;\n\t}";
                        out.write(outputstring, 0, outputstring.length());



                        outputstring = "\n\tprivate static boolean Evaluate"+ i +"(int var, ReteToken token)\n\t{\n";
                        out.write(outputstring, 0, outputstring.length());
                        outputstring = "\t\tif((double)var " + str[2] + " ";
                        out.write(outputstring, 0, outputstring.length());

                        for(int k = 0; k<st.length; k++)
                        {
                                String ss = " " + st[k] + " ";
                                int ind = aliasname_list.indexOf(ss);

                                if(ind >= 0)
                                {
                                        outputstring = "((Number)(token.variable[" + ind + "])).doubleValue()";
                                        out.write(outputstring, 0, outputstring.length());
                                }
                                else
                                {
                                        if(st[k].length() > 0 && st[k].compareTo("+") != 0)
                                                dostring = false;
                                        out.write(st[k], 0, st[k].length());
                                }
                        }
                        outputstring = ") return true;\n\t\treturn false;\n\t}";
                        out.write(outputstring, 0, outputstring.length());

                        outputstring = "\n\tprivate static boolean Evaluate"+ i +"(Double var, ReteToken token)\n\t{\n";
                        out.write(outputstring, 0, outputstring.length());

                        outputstring = "\t\tif(var == null) return false;\n";
                        out.write(outputstring, 0, outputstring.length());


                        outputstring = "\t\tif(var.doubleValue() " + str[2] + " ";
                        out.write(outputstring, 0, outputstring.length());

                        for(int k = 0; k<st.length; k++)
                        {
                                String ss = " " + st[k] + " ";
                                int ind = aliasname_list.indexOf(ss);

                                if(ind >= 0)
                                {
                                        outputstring = "((Number)(token.variable[" + ind + "])).doubleValue()";
                                        out.write(outputstring, 0, outputstring.length());
                                }
                                else
                                {
                                        out.write(st[k], 0, st[k].length());
                                }
                        }
                        outputstring = ") return true;\n\t\treturn false;\n\t}";
                        out.write(outputstring, 0, outputstring.length());

                        outputstring = "\n\tprivate static boolean Evaluate"+ i +"(double var, ReteToken token)\n\t{\n";
                        out.write(outputstring, 0, outputstring.length());
                        outputstring = "\t\tif(var " + str[2] + " ";
                        out.write(outputstring, 0, outputstring.length());

                        for(int k = 0; k<st.length; k++)
                        {
                                String ss = " " + st[k] + " ";
                                int ind = aliasname_list.indexOf(ss);

                                if(ind >= 0)
                                {
                                        outputstring = "((Number)(token.variable[" + ind + "])).doubleValue()";
                                        out.write(outputstring, 0, outputstring.length());
                                }
                                else
                                {
                                        out.write(st[k], 0, st[k].length());
                                }
                        }
                        outputstring = ") return true;\n\t\treturn false;\n\t}";
                        out.write(outputstring, 0, outputstring.length());

                        if(dostring)
                        {
                                outputstring = "\n\tprivate static boolean Evaluate"+ i +"(String var, ReteToken token)\n\t{\n";
                                out.write(outputstring, 0, outputstring.length());

                                outputstring = "\t\tif(var == null) return false;\n";
                                out.write(outputstring, 0, outputstring.length());

                                outputstring = "\t\tif(var.compareTo(";
                                out.write(outputstring, 0, outputstring.length());

                                for(int k = 0; k<st.length; k++)
                                {
                                        String ss = " " + st[k] + " ";
                                        int ind = aliasname_list.indexOf(ss);

                                        if(ind >= 0)
                                        {
                                                outputstring = "token.variable[" + ind + "].toString()";
                                                out.write(outputstring, 0, outputstring.length());
                                        }
                                        else
                                        {
                                                out.write(st[k], 0, st[k].length());
                                        }
                                }
                                outputstring = ") "+ str[2] + " 0) return true;\n\t\treturn false;\n\t}";
                                out.write(outputstring, 0, outputstring.length());
                        }
                        out.write("\n", 0, 1);
                }

                outputstring = "\n\tprivate static boolean Evaluate(ReteToken token)\n\t{";
                out.write(outputstring, 0, outputstring.length());

                for(int i=0; i<anyalias_list.size(); i++)
                {
                        StringBuffer sb = new StringBuffer();
                        String[] str, st;

                        str = reduced_list.get(((Integer)anyalias_list.get(i)).intValue()-1).toString().split(" ");
                        for(int j = 0; j<aliasname_list.size(); j++) vars[j] = false;
                        for(int j = 0; j<str.length; j++)
                        {
                                String ss = " " + str[j] + " ";
                                int ind = aliasname_list.indexOf(ss);
                                if(ind >= 0)
                                {
                                        vars[ind] = true;
                                }
                        }

                        for(int j = 0; j<aliasname_list.size(); j++)
                        {
                                if(vars[j])
                                {
                                        sb.append("(token.typeofvariable[" + j + "]!=0) || ");
                                }
                        }

                        if(sb.length()>4)
                        {
                                boolean dostring = true;

                                sb.delete(sb.length()-4, sb.length());

                                outputstring = "\n\t\tif(token.check[" + i + "]==1)\n\t\t\tif(";
                                out.write(outputstring, 0, outputstring.length());
                                out.write(sb.toString(), 0, sb.length());
                                outputstring = ")\n\t\t\t{\n";
                                out.write(outputstring, 0, outputstring.length());

                                str = reduced_list.get(((Integer)anyalias_list.get(i)).intValue()-1).toString().split(":");
/*				
				outputstring = "\t\t\t\tif((("+ str[0] +")token.object["+ i +"])."
					+ str[1] +" == null) {token.check["+ i +"]=3; return false;}\n";
				out.write(outputstring, 0, outputstring.length());
*/
                                outputstring = "\t\t\t\tif(Evaluate"+ i +"((("+ str[0] +")token.object["+ i +"])."
                                        + str[1] +", token))\n\t\t\t\t{\n";
                                out.write(outputstring, 0, outputstring.length());

                                outputstring = "\t\t\t\t\ttoken.check["+ i +"] = 2;\n";
                                out.write(outputstring, 0, outputstring.length());
                                /*if(modeII)
				{
					outputstring = "\t\t\t\t\ttoken.certainty = Certainty(" + 
						"(("+ str[0] +")token.object["+ i +"])._Certainty_" + str[1] + ", " +
						"(("+ str[0] +")token.object["+ i +"])._LS_" + str[1] + ", " +
						"(("+ str[0] +")token.object["+ i +"])._LN_" + str[1] + ", " +
						"VarsInCheck" + i + ", true);\n";
					out.write(outputstring, 0, outputstring.length());
				}*/
                                outputstring = "\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n";
                                out.write(outputstring, 0, outputstring.length());
                                outputstring = "\t\t\t\t\ttoken.check["+ i +"] = 3;\n";
                                out.write(outputstring, 0, outputstring.length());
                                /*if(modeII)
				{
					outputstring = "\t\t\t\t\ttoken.certainty = Certainty(" + 
						"(("+ str[0] +")token.object["+ i +"])._Certainty_" + str[1] + ", " +
						"(("+ str[0] +")token.object["+ i +"])._LS_" + str[1] + ", " +
						"(("+ str[0] +")token.object["+ i +"])._LN_" + str[1] + ", " +
						"VarsInCheck" + i + ", false);\n";
					out.write(outputstring, 0, outputstring.length());
				}*/
                                outputstring = "\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}";
                                out.write(outputstring, 0, outputstring.length());
                        }
                }
                outputstring = "\n\t\treturn true;\n\t};";
                out.write(outputstring, 0, outputstring.length());
                out.write("\n", 0, 1);
        }

        public static void WriteFeedingSlots(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String[] sto;
                String[] str;
                String[] st;
                ArrayList object_list = new ArrayList();

                for(int i=0; i< reduced_list.size(); i++)
                {
                        sto = reduced_list.get(i).toString().split(":");
                        if(!object_list.contains(sto[0])) object_list.add(sto[0]);
                }

                for(int obn=0; obn < object_list.size(); obn++)
                {
                        int last_cond = 0;
                        sto = object_list.get(obn).toString().split(":");

                        if(obn>0)
                                outputstring = "\t\telse if(obj.getClass().getName().compareTo(\"ReteObjects." + sto[0] + "\")==0)\n\t\t{\n";
                        else
                                outputstring = "\t\tif(obj.getClass().getName().compareTo(\"ReteObjects." + sto[0] + "\")==0)\n\t\t{\n";
                        out.write(outputstring, 0, outputstring.length());

                        for(int i=0; i< tokensender_list.size(); i++)
                        {
                                str = tokensender_list.get(i).toString().split(":");
                                int ii = (new Integer(str[0])).intValue();
                                st = reduced_list.get(ii-1).toString().split(":");

                                if(last_cond<ii)
                                {
                                        last_cond = ii;
                                        if(sto[0].compareTo(st[0]) == 0)
                                        {
//						str = tokensender_list.get(i).toString().split(":");
//						Integer ii = new Integer(str[0]);
                                                Integer oo = new Integer(str[1]);
                                                Integer cc = new Integer(str[2]);
                                                Integer vv = new Integer(str[3]);

                                                outputstring = "//\u0009"+ reduced_list.get(ii-1).toString() + "\u0009" + tokensender_list.get(i).toString() +"\n";
                                                out.write(outputstring, 0, outputstring.length());

                                                outputstring = "\t\t\ttoken = new ReteToken();\n\t\t\ttoken.ClearToken();\n";
                                                out.write(outputstring, 0, outputstring.length());
                                                outputstring = "\t\t\ttoken.object[" + oo.intValue() + "] = obj;\n";
                                                out.write(outputstring, 0, outputstring.length());
                                                outputstring = "\t\t\ttoken.timestamps[" + oo.intValue() + "] = time_stamp;\n";
                                                out.write(outputstring, 0, outputstring.length());

                                                if(modeII)
                                                {
                                                        outputstring = "\t\t\ttoken.P_H_Ep = (("+ st[0] +")obj)._P_H_Ep_" + st[1] + ";\n";
                                                        out.write(outputstring, 0, outputstring.length());
                                                        outputstring = "\t\t\ttoken.LSp_from_P_H_Ep();\n";
                                                        out.write(outputstring, 0, outputstring.length());
                                                }

                //instant evaluation
                                                if(cc.intValue()==0)
                                                {
                                                        if(vv.intValue()==4)
                                                        {
                                                                outputstring = "\t\t\tif(TypeOfObject((("+ st[0] +")obj)."+ st[1] +") == 1)\n";
                                                                out.write(outputstring, 0, outputstring.length());
                                                                outputstring = "\t\t\t{\n";
                                                                out.write(outputstring, 0, outputstring.length());

                                                                outputstring = "\t\t\t\tif((("+ st[0] +")obj)."+ st[1] +" != null)\n";
                                                                out.write(outputstring, 0, outputstring.length());
                                                                outputstring = "\t\t\t\tif((("+ st[0] +")obj)."+ st[1]
                                                                        +".compareTo("+ st[3] +")"+ st[2] +"0)\n\t\t\t\t\tCondition"+ ii
                                                                        +".InputCondition(token);\n";
                                                                out.write(outputstring, 0, outputstring.length());
                                                                outputstring = "\t\t\t}\n";
                                                                out.write(outputstring, 0, outputstring.length());

                                                        }
                                                        if(vv.intValue()==1 || vv.intValue()==2 || vv.intValue()==3)
                                                        {
                                                                outputstring = "\t\t\tif(TypeOfObject((("+ st[0] +")obj)."+ st[1] +") == 2 || TypeOfObject((("+ st[0] +")obj)."+ st[1] +") == 3)\n";
                                                                out.write(outputstring, 0, outputstring.length());
                                                                outputstring = "\t\t\t{\n";
                                                                out.write(outputstring, 0, outputstring.length());

                                                                outputstring = "\t\t\t\tif((("+ st[0] +")obj)."+st[1]+" "
                                                                        +st[2]+" "+st[3]+")\n\t\t\t\t\tCondition"+ ii
                                                                        +".InputCondition(token);\n";

                                                                out.write(outputstring, 0, outputstring.length());
                                                                outputstring = "\t\t\t}\n\n";
                                                                out.write(outputstring, 0, outputstring.length());
                                                        }
                                                }

                //check
                                                else if(cc.intValue()<0)
                                                {
                                                        outputstring = "\t\t\ttoken.check["+ (-cc.intValue()-1) +"] = 1;\n";
                                                        out.write(outputstring, 0, outputstring.length());
                                                        outputstring = "\t\t\tCondition"+ ii +".InputCondition(token);\n\n";
                                                        out.write(outputstring, 0, outputstring.length());
                                                }

                //variable substitution
                                                else
                                                {
                                                        outputstring = "\t\t\ttoken.variable["+ (cc.intValue()-1) +"] = ReturnClass((("+ st[0] +")obj)."+ st[1] +");\n";
                                                        out.write(outputstring, 0, outputstring.length());
                                                        outputstring = "\t\t\ttoken.typeofvariable["+ (cc.intValue()-1) +"] = TypeOfObject((("+ st[0] +")obj)."+ st[1] +");\n";
                                                        out.write(outputstring, 0, outputstring.length());
                                                        outputstring = "\t\t\tCondition"+ ii +".InputCondition(token);\n\n";
                                                        out.write(outputstring, 0, outputstring.length());
                                                }
                                        }
                                }
                        }
                        outputstring = "\t\t}\n";
                        out.write(outputstring, 0, outputstring.length());
                }
        }







        public static void WriteUnFeedingSlots(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String[] sto;
                String[] str;
                String[] st;
                ArrayList object_list = new ArrayList();

                for(int i=0; i< reduced_list.size(); i++)
                {
                        sto = reduced_list.get(i).toString().split(":");
                        if(!object_list.contains(sto[0])) object_list.add(sto[0]);
                }

                for(int obn=0; obn < object_list.size(); obn++)
                {
                        int last_cond = 0;
                        sto = object_list.get(obn).toString().split(":");

                        if(obn>0)
                                outputstring = "\t\telse if(obj.getClass().getName().compareTo(\"ReteObjects." + sto[0] + "\")==0)\n\t\t{\n";
                        else
                                outputstring = "\t\tif(obj.getClass().getName().compareTo(\"ReteObjects." + sto[0] + "\")==0)\n\t\t{\n";
                        out.write(outputstring, 0, outputstring.length());

                        for(int i=0; i< tokensender_list.size(); i++)
                        {
                                str = tokensender_list.get(i).toString().split(":");
                                int ii = (new Integer(str[0])).intValue();
                                st = reduced_list.get(ii-1).toString().split(":");

                                if(last_cond<ii)
                                {
                                        last_cond = ii;
                                        if( sto[0].compareTo(st[0]) == 0)
                                        {
                                                outputstring = "\t\t\tCondition"+ ii +".RemoveObsoleteTokens(obj);\n";
                                                out.write(outputstring, 0, outputstring.length());
                                        }
                                }
                        }
                        outputstring = "\t\t}\n";
                        out.write(outputstring, 0, outputstring.length());
                }
        }

        public static void WriteConvertToAny(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String[] sto;
                ArrayList object_list = new ArrayList();

                for(int i=0; i< reduced_list.size(); i++)
                {
                        sto = reduced_list.get(i).toString().split(":");
                        if(!object_list.contains(sto[0])) object_list.add(sto[0]);
                }

                for(int obn=0; obn < object_list.size(); obn++)
                {
                        sto = object_list.get(obn).toString().split(":");
/*
			if(obn>0)
				outputstring = "\t\telse if(obj.getClass().getName().compareTo(\"ReteObjects." + sto[0] + "\")==0) "
				+ sto[0] + "Helper.insert(anyholder, ("+ sto[0] +")obj);\n\t\t";
			else
				outputstring = "\t\tif(obj.getClass().getName().compareTo(\"ReteObjects." + sto[0] + "\")==0) "
				+ sto[0] + "Helper.insert(anyholder, ("+ sto[0] +")obj);\n\t\t";
*/
                        if(obn>0)
                                outputstring = "\t\telse if(classname.compareTo(\"ReteObjects." + sto[0] + "\")==0) "
                                + sto[0] + "Helper.insert(anyholder, ("+ sto[0] +")obj);\n\t\t";
                        else
                                outputstring = "\t\tif(classname.compareTo(\"ReteObjects." + sto[0] + "\")==0) "
                                + sto[0] + "Helper.insert(anyholder, ("+ sto[0] +")obj);\n\t\t";
                        out.write(outputstring, 0, outputstring.length());
                }
        }

        public static void WriteConvertFromAny(FileWriter out) throws IOException
        {
                String outputstring = new String();
                String[] sto;
                ArrayList object_list = new ArrayList();

                for(int i=0; i< reduced_list.size(); i++)
                {
                        sto = reduced_list.get(i).toString().split(":");
                        if(!object_list.contains(sto[0])) object_list.add(sto[0]);
                }

                for(int obn=0; obn < object_list.size(); obn++)
                {
                        sto = object_list.get(obn).toString().split(":");

                        if(obn>0)
                                outputstring = "\t\telse if(ah.value.type().name().compareTo(\"" + sto[0] + "\")==0) obj = "
                                + sto[0] + "Helper.extract(ah.value);\n\t\t";
                        else
                                outputstring = "\t\tif(ah.value.type().name().compareTo(\"" + sto[0] + "\")==0) obj = "
                                + sto[0] + "Helper.extract(ah.value);\n\t\t";
                        out.write(outputstring, 0, outputstring.length());
                }
        }

/*
TOKEN :
{
	<WHATEVER: (~["{","}"," ","\t","\n","\r"])*>
}
*/

//==============================================================================
  static final public void Start() throws ParseException {
    label_1:
    while (true) {
      rule();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
                int aku = 0;
                int max_rul_merit;
                int max_rul_priority;
                int rul_with_max_merit;
                do
                {
                        max_rul_merit = -1;
                        max_rul_priority = -1;
                        rul_with_max_merit = -1;

                        for(int i=rulemerit_list.size()-1; i>=0; i--)
                        {
                                if(max_rul_merit<((Integer)rulemerit_list.get(i)).intValue())
                                {
                                        max_rul_merit = ((Integer)rulemerit_list.get(i)).intValue();
                                        rul_with_max_merit = i;

                                        String[] str;
                                        str = rule_list.get(i).toString().split(":");
                                        max_rul_priority = (new Integer(str[5])).intValue();
                                }
                                else if(max_rul_merit >= 0 && max_rul_merit==((Integer)rulemerit_list.get(i)).intValue())
                                {
                                        String[] str;
                                        str = rule_list.get(i).toString().split(":");
                                        int rul_priority = (new Integer(str[5])).intValue();

                                        if(max_rul_priority < rul_priority)
                                        {
                                                rul_with_max_merit = i;
                                                max_rul_priority = rul_priority;
                                        }
                                }
                        }
                        if(rul_with_max_merit >= 0)
                        {
                                aku++;
                                rulemerit_list.set(rul_with_max_merit, new Integer(-aku));
                        }
                }while(rul_with_max_merit >= 0);
  }

//==============================================================================
  static final public void rule() throws ParseException {
        int i_slot;
        String current_rulename;
        String s_ruleprior;
    jj_consume_token(50);
    jj_consume_token(RULE);
    jj_consume_token(51);
    current_rulename = rulename();
    s_ruleprior = ruleprior();
    jj_consume_token(IF);
    i_slot = condblock();
    jj_consume_token(THEN);
    actblock();
    jj_consume_token(52);
                rules_count++;
//		System.out.println("Rule: " + rules_count);
                rule_list.add(current_rulename + ":" + i_slot + ":" + object_list.size() + ":" + noofconditions + ":" + meaobject + ":" + s_ruleprior);
                rulemerit_list.add(new Integer(noofconditions));

                RulesVIR_List.add(VarsInRule_List);
                VarsInRule_List = new ArrayList();

                RulesCIR_List.add(CondsInRule_List);
                CondsInRule_List = new ArrayList();

/*
		System.out.println("Objects of " + s_rulename);
		for(int i=0; i< object_list.size(); i++)
			System.out.println((i+1)+"\t"+object_list.get(i).toString());

		System.out.println("Vars of " + s_rulename);
		for(int i=0; i< varvar_list.size(); i++)
			System.out.println((i+1)+"\t"+varvar_list.get(i).toString());
*/
                if(maxnoofconditions<noofconditions) maxnoofconditions = noofconditions;
                noofconditions = 0;
                if(noofobjects < object_list.size()) noofobjects = object_list.size();

                object_list.clear();
                varvar_list.clear();
                meaobject = -1;

//		execute_code.append("\t}\n\n");

                classX_objects_list.clear();
                class_objectsX_list.clear();
  }

//==============================================================================
  static final public String rulename() throws ParseException {
        Token rule_token;
        String s_rule;
    rule_token = jj_consume_token(IDENTIFIER);
                s_rule = rule_token.image;// + ":" + (slot_list.size()+1) + ":" + (-node_list.size()-1);

                //if(rule_list.contains(s_rule)) System.out.println("\t---Rule " + s_rule + "already defined");
                //rule_list.add(s_rule);

                if(rulename_list.contains(rule_token.image))
                        System.out.println("("+rule_token.beginLine +")\tRule " + rule_token.image      +" already defined");
                rulename_list.add(s_rule);

                if(rules_count>0) execute_code.append("\t}\n\n");
                execute_code.append("\n\tpublic void Execute_"+ s_rule
                        + "(ReteToken token) throws NoSuchFieldException, IllegalAccessException, IOException, org.omg.CORBA.TypeCodePackage.BadKind\n\t{\n");

                {if (true) return s_rule;}
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String ruleprior() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
                {if (true) return t.image;}
      break;
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
                {if (true) return t.image;}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public int condblock() throws ParseException {
//	Token object_token;
        Token slot_token;
        int i_slot;
        String s_node;
        String s_node2;
        int slot1, slot2;
    if (jj_2_1(2)) {
      jj_consume_token(50);
      jj_consume_token(CLASS);
      jj_consume_token(51);
      class_token = jj_consume_token(IDENTIFIER);
      jj_consume_token(OBJ);
      jj_consume_token(51);
      jj_consume_token(53);
      obj_token = jj_consume_token(IDENTIFIER);
      i_slot = slot_ops();
      jj_consume_token(52);
//		cond_blocks+=100;

                if(!class_objectsX_list.contains(obj_token.image))
                {
                        class_objectsX_list.add(obj_token.image);
                        classX_objects_list.add(class_token.image);
                }

                {if (true) return i_slot;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        slot1 = condblock();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          slot_token = jj_consume_token(OR);
          break;
        case AND:
          slot_token = jj_consume_token(AND);
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        slot2 = condblock();
        jj_consume_token(52);
                noofconditions++;
//		cond_blocks++;
                if(slot_token.image.compareTo("OR")==0)
                {
                        s_node = "OR " + slot1 +" "+ slot2;
                        s_node2 = "OR " + slot2 +" "+ slot1;
                        if(node_list.contains(s_node))
                        {
//				System.out.println(s_node + "+");
                                {if (true) return -(node_list.indexOf(s_node)+1);}
                        }
                        else if(node_list.contains(s_node2))
                        {
//				System.out.println(s_node2 + "+");
                                {if (true) return -(node_list.indexOf(s_node2)+1);}
                        }
                        else
                        {
//				System.out.println(s_node + "-");
                                node_list.add(s_node);
                                {if (true) return -node_list.size();}
                        }
                }
                else
                {
                        s_node = "AND " + slot1 +" "+ slot2;
                        s_node2 = "AND " + slot2 +" "+ slot1;
                        if(node_list.contains(s_node))
                        {
//				System.out.println(s_node + "+");
                                {if (true) return -(node_list.indexOf(s_node)+1);}
                        }
                        else if(node_list.contains(s_node2))
                        {
//				System.out.println(s_node2 + "+");
                                {if (true) return -(node_list.indexOf(s_node2)+1);}
                        }
                        else
                        {
//				System.out.println(s_node + "-");
                                node_list.add(s_node);
                                {if (true) return -node_list.size();}
                        }
                }
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public int slot_ops() throws ParseException {
        Token slot_token;
        String s_expr;
        String s_lop;
        String s_slot;
        String s_reduced;
        String s_variable;
        String s_node;
        String s_node2;
//	boolean already;
        int slot1, slot2;
        Integer no_of_alias;
        int object, to_reduce;
    if (jj_2_2(2)) {
      jj_consume_token(50);
      slot_token = jj_consume_token(IDENTIFIER);
      s_lop = lop();
      s_expr = expr();
      jj_consume_token(52);
                object = object_list.indexOf(obj_token.image);
                if(object<0)
                {
                        object = object_list.size();
                        object_list.add(obj_token.image);
                }

                if(meaobject<0) meaobject = object;

                s_slot = class_token.image + ":" + slot_token.image;
                if(!VarsInRule_List.contains(s_slot)) VarsInRule_List.add(s_slot);

                s_slot = class_token.image + ":" + object + ":" + slot_token.image
                                 + ":" + s_lop + ":" + s_expr;
                s_reduced = class_token.image + ":" + slot_token.image
                                 + ":" + s_lop + ":" + s_expr;
                s_variable = class_token.image + ":" + slot_token.image;

                if(!(s_lop == "==" || s_lop == "EQ")) alias_condition = false;

                if(slot_list.contains(s_slot))
                {
//			System.out.println("\t--Already in");
                        alias_condition = true;
                        anyalias_condition = false;
                        variabletype = 0;

                        Integer trds = new Integer(reduced_list.indexOf(s_reduced)+1);
                        if(!CondsInRule_List.contains(trds)) CondsInRule_List.add(trds);

                        {if (true) return slot_list.indexOf(s_slot)+1;}
                }
                else
                {
                        int type;
                        int ind = 0;
                        if(reduced_list.contains(s_reduced))
                        {
                                to_reduce=reduced_list.indexOf(s_reduced)+1;
                        }
                        else
                        {
                                reduced_list.add(s_reduced);
                                to_reduce = reduced_list.size();
                        }

                        Integer trds = new Integer(to_reduce);
                        if(!CondsInRule_List.contains(trds)) CondsInRule_List.add(trds);
//			System.out.println("\t++Added");

                        if(anyalias_condition)
                        {
                                if(!alias_condition)
                                {
                                        no_of_alias = new Integer(slot_list.size()+1);
                                        anyalias_list.add(no_of_alias);
                                        ind = -anyalias_list.size();
                                }
                        }

                        if(alias_condition)
                        {
                                ind = aliasname_list.indexOf(s_expr);
                                if(ind < 0)
                                {
                                        aliasname_list.add(s_expr);
                                        ind = aliasname_list.size();
                                }
                                else ind++;
                        }

                        slot_list.add(s_slot);
                        tokensender_list.add((to_reduce) + ":" + (object) + ":" + ind + ":" + variabletype);

                        if((variabletype & 3) > 0 && (variabletype & 4) > 0)
                                System.out.println("(" +slot_token.beginLine+ ")\tMixed strings and numbers in: " + s_reduced);
                        variabletype = 0;

                        alias_condition = true;
                        anyalias_condition = false;

                        {if (true) return slot_list.size();}
                }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        slot1 = slot_ops();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          slot_token = jj_consume_token(OR);
          break;
        case AND:
          slot_token = jj_consume_token(AND);
          break;
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        slot2 = slot_ops();
        jj_consume_token(52);
                noofconditions++;
                if(slot_token.image.compareTo("OR")==0)
                {
                        s_node = "OR " + slot1 +" "+ slot2;
                        s_node2 = "OR " + slot2 +" "+ slot1;
                        if(node_list.contains(s_node))
                        {
//				System.out.println(s_node + "+");
                                {if (true) return -(node_list.indexOf(s_node)+1);}
                        }
                        else if(node_list.contains(s_node2))
                        {
//				System.out.println(s_node2 + "+");
                                {if (true) return -(node_list.indexOf(s_node2)+1);}
                        }
                        else
                        {
//				System.out.println(s_node + "-");
                                node_list.add(s_node);
                                {if (true) return -node_list.size();}
                        }
                }
                else
                {
                        s_node = "AND " + slot1 +" "+ slot2;
                        s_node2 = "AND " + slot2 +" "+ slot1;
                        if(node_list.contains(s_node))
                        {
//				System.out.println(s_node + "+");
                                {if (true) return -(node_list.indexOf(s_node)+1);}
                        }
                        else if(node_list.contains(s_node2))
                        {
//				System.out.println(s_node2 + "+");
                                {if (true) return -(node_list.indexOf(s_node2)+1);}
                        }
                        else
                        {
//				System.out.println(s_node + "-");
                                node_list.add(s_node);
                                {if (true) return -node_list.size();}
                        }
                }
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public void actblock() throws ParseException {
    jj_consume_token(50);
    label_2:
    while (true) {
      actionstatement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(52);
  }

//==============================================================================
  static final public void actionstatement() throws ParseException {
        Token t_class;
        Token t_object;

        Token t_name;
        //StringBuffer buffer = new StringBuffer();
        ArrayList vsub_list = new ArrayList();
        String s_expr;
        String outputstring;
        class_variables_list.clear();
        String s_lsno;
        String s_lnno;
    if (jj_2_10(2)) {
      jj_consume_token(50);
      jj_consume_token(MODIFY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        jj_consume_token(OBJ);
        jj_consume_token(51);
        jj_consume_token(53);
        t_object = jj_consume_token(IDENTIFIER);
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            ;
            break;
          default:
            jj_la1[7] = jj_gen;
            break label_3;
          }
          jj_consume_token(50);
          variableitem(vsub_list);
          jj_consume_token(52);
        }
        jj_consume_token(52);
        break;
      case OBJ:
        jj_consume_token(OBJ);
        jj_consume_token(51);
        jj_consume_token(53);
        t_object = jj_consume_token(IDENTIFIER);
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_4;
          }
          jj_consume_token(50);
          variableitem(vsub_list);
          jj_consume_token(52);
        }
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s_lsno = lsno();
      s_lnno = lnno();
      jj_consume_token(52);
/*
		outputstring = "// MODIFY: object = " + t_object.image + "\n";
		execute_code.append(outputstring);

		for(int i=0; i< vsub_list.size(); i++)
		{
			String[] sp = vsub_list.get(i).toString().split("=");

			outputstring = "\t\too = token.object[" + object_list.indexOf(t_object.image) + "];\n";
			execute_code.append(outputstring);
			outputstring = "\t\tif(oo != null)\n";
			execute_code.append(outputstring);
			outputstring = "\t\t{\n";
			execute_code.append(outputstring);
			outputstring = "\t\t\tff = oo.getClass().getDeclaredField(\"" + sp[0] + "\");\n";
			execute_code.append(outputstring);
			outputstring = "\t\t\tSetField(oo, ff, " + sp[1] + ");\n";
			execute_code.append(outputstring);
			outputstring = "\t\t\tnetwork.MemSetObject(oo);\n";
			execute_code.append(outputstring);
			outputstring = "\t\t}\n";
			execute_code.append(outputstring);
		}
*/

                int coi = class_objectsX_list.indexOf(t_object.image);
                if(coi>=0)
                        for(int i=0; i< class_variables_list.size(); i++)
                                MODIFY_list.add(classX_objects_list.get(coi)+":"+class_variables_list.get(i)+" "+rules_count+" "+s_lsno+" "+s_lnno);

                outputstring = "// MODIFY: object = " + t_object.image + "\n";
                execute_code.append(outputstring);

                outputstring = "\t\too = token.object[" + object_list.indexOf(t_object.image) + "];\n";
                execute_code.append(outputstring);
                outputstring = "\t\tif(oo != null)\n";
                execute_code.append(outputstring);
                outputstring = "\t\t{\n";
                execute_code.append(outputstring);

                for(int i=0; i< vsub_list.size(); i++)
                {
                        String[] sp = vsub_list.get(i).toString().split("=");

                        outputstring = "\t\t\tff = oo.getClass().getDeclaredField(\"" + sp[0] + "\");\n";
                        execute_code.append(outputstring);

                        if(sp[1].startsWith("token.variable"))
                        {
                                outputstring = "\t\t\tSetField(oo, ff, " + sp[1] + ", token.typeofvariable" + sp[1].substring(14) + ");\n";
                                execute_code.append(outputstring);
                        }
                        else if(sp[1].startsWith(" token.variable"))
                        {
                                outputstring = "\t\t\tSetField(oo, ff, " + sp[1] + ", token.typeofvariable" + sp[1].substring(15) + ");\n";
                                execute_code.append(outputstring);
                        }
                        else
                        {
                                outputstring = "\t\t\tSetField(oo, ff, " + sp[1] + ");\n";
                                execute_code.append(outputstring);
                        }

                        if(modeII)
                        {
                                outputstring = "\t\t\tff = oo.getClass().getDeclaredField(\"_P_H_Ep_" + sp[0] + "\");\n";
                                execute_code.append(outputstring);
// There are three possibilities for sp[1]:
// - local variable set with READ PROMPT - $Rule_no$Name_of_variable
// - constant value - 1263
// - global variable - token.variable[1]
                                if(sp[1].startsWith(" $"))
                                {
                                        outputstring = "\t\t\tSetField(oo, ff, ProbabilityFromCertainty(_Certainty_" + sp[1].substring(1)+ ", " + s_lsno + ", " + s_lnno + "));\n";
                                        execute_code.append(outputstring);
                                }
                                else
                                {
                                        outputstring = "\t\t\tSetField(oo, ff, ProbabilityFromTotal(token.P_H_Ep_total, " + s_lsno + ", " + s_lnno + "));\n";
                                        execute_code.append(outputstring);
                                }
                        }

/*
			if(modeII)
			{
				String temp;
// There are three possibilities for sp[1]:
// - local variable set with READ PROMPT - $Rule_no$Name_of_variable
// - constant value - 1263
// - global variable - token.variable[1]
				if(sp[1].startsWith(" $") temp = "_Certainty_" + sp[1].substring(1);
				else if(sp[1].startsWith("token.variable") temp = "token.certaintyofvariable" + sp[14].substring(1);
				else temp = "_Certainty_of_rule_";
				outputstring = "\t\t\tff = oo.getClass().getDeclaredField(\"_Certainty_" + sp[0] + "\");\n";
				execute_code.append(outputstring);
				outputstring = "\t\t\tSetField(oo, ff, " + temp + ");\n";
				execute_code.append(outputstring);
				outputstring = "\t\t\tff = oo.getClass().getDeclaredField(\"_LS_" + sp[0] + "\");\n";
				execute_code.append(outputstring);
				outputstring = "\t\t\tSetField(oo, ff, " + s_lsno + ");\n";
				execute_code.append(outputstring);
				outputstring = "\t\t\tff = oo.getClass().getDeclaredField(\"_LN_" + sp[0] + "\");\n";
				execute_code.append(outputstring);
				outputstring = "\t\t\tSetField(oo, ff, " + s_lnno + ");\n";
				execute_code.append(outputstring);
			}
*/
                }


                outputstring = "\t\t}\n";
                execute_code.append(outputstring);
//		outputstring = "\t\telse network.MemSetObject(oo, null);\n";
                outputstring = "\t\tnetwork.MemSetObject(oo, null);\n";
                execute_code.append(outputstring);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        if (jj_2_9(2)) {
          jj_consume_token(50);
          jj_consume_token(MAKE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            jj_consume_token(50);
            jj_consume_token(CLASS);
            jj_consume_token(51);
            t_class = jj_consume_token(IDENTIFIER);
            jj_consume_token(OBJ);
            jj_consume_token(51);
            t_object = jj_consume_token(IDENTIFIER);
            label_5:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                ;
                break;
              default:
                jj_la1[10] = jj_gen;
                break label_5;
              }
              jj_consume_token(50);
              variableitem(vsub_list);
              jj_consume_token(52);
            }
            jj_consume_token(52);
            jj_consume_token(52);
            break;
          case CLASS:
            jj_consume_token(CLASS);
            jj_consume_token(51);
            t_class = jj_consume_token(IDENTIFIER);
            jj_consume_token(OBJ);
            jj_consume_token(51);
            t_object = jj_consume_token(IDENTIFIER);
            label_6:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                ;
                break;
              default:
                jj_la1[11] = jj_gen;
                break label_6;
              }
              jj_consume_token(50);
              variableitem(vsub_list);
              jj_consume_token(52);
            }
            jj_consume_token(52);
            break;
          default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                MAKE_list.add(t_class.image+":"+t_object.image+" "+rules_count);

                outputstring = "// MAKE: class = " + t_class.image + " object = " + t_object.image + "\n";
                execute_code.append(outputstring);

                outputstring = "\t\t"+ t_class.image + " " + t_object.image + " = new " + t_class.image +"();\n";
                execute_code.append(outputstring);

                for(int i=0; i< vsub_list.size(); i++)
                {
                        outputstring = "\t\t" + t_object.image +"."+ vsub_list.get(i).toString()+";\n";
                        execute_code.append(outputstring);
                        if(modeII)
                        {
                                String name = vsub_list.get(i).toString().substring(0, vsub_list.get(i).toString().indexOf("="));
/*
				outputstring = "\t\t\t" + t_object.image +"._LS_"+ name + " = 0;\n";
				execute_code.append(outputstring);
				outputstring = "\t\t\t" + t_object.image +"._LN_"+ name + " = 0;\n";
				execute_code.append(outputstring);
*/
                                outputstring = "\t\t\t" + t_object.image +"._P_H_Ep_"+ name + " = 1.0f;\n";
                                execute_code.append(outputstring);
                        }
                }

                outputstring = "\t\tnetwork.MemSetObject((Object)" + t_object.image + ", \"" + t_object.image + "\");\n\n";
                execute_code.append(outputstring);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            if (jj_2_8(2)) {
              jj_consume_token(50);
              jj_consume_token(REMOVE);
              jj_consume_token(OBJ);
              jj_consume_token(51);
              jj_consume_token(53);
              t_object = jj_consume_token(IDENTIFIER);
              jj_consume_token(52);
                outputstring = "// REMOVE: object = " + t_object.image + "\n";
                execute_code.append(outputstring);

                outputstring = "\t\tnetwork.MemSetObject(null, \"" + t_object.image + "\");\n\n";
                execute_code.append(outputstring);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                if (jj_2_7(2)) {
                  jj_consume_token(50);
                  jj_consume_token(PRINT);
                  s_expr = expr_ia();
                  label_7:
                  while (true) {
                    if (jj_2_3(2)) {
                      ;
                    } else {
                      break label_7;
                    }
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case 54:
                    case 55:
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      case 55:
                        jj_consume_token(55);
                        break;
                      default:
                        jj_la1[13] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                      }
                      break;
                    default:
                      jj_la1[14] = jj_gen;
                      ;
                    }
                    variableitem2(vsub_list);
                  }
                  jj_consume_token(52);
                outputstring = "// PRINT\n";
                execute_code.append(outputstring);


//???????????????????????????????????????????????????????????????????????????


                vsub_list.add(0, s_expr);
                for(int k = 0; k < vsub_list.size(); k++)
                {
                        outputstring = "\t\tPrint((String)" + vsub_list.get(k) + ");\n";
                        //outputstring = "\t\tSystem.out.print(" + vsub_list.get(k) + ");\n";
                        execute_code.append(outputstring);
                };
                outputstring = "\t\tPrint(\"\\n\");\n";
//		outputstring = "\t\tSystem.out.print(\"\\n\");\n";
                execute_code.append(outputstring);
                } else {
                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                  case 50:
                    if (jj_2_6(2)) {
                      jj_consume_token(50);
                      jj_consume_token(READ);
                      jj_consume_token(PROMPT);
                      jj_consume_token(51);
                      t_object = jj_consume_token(STRING_LITERAL);
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      default:
                        jj_la1[15] = jj_gen;
                        ;
                      }
                      jj_consume_token(VAR);
                      jj_consume_token(51);
                      jj_consume_token(53);
                      t_name = jj_consume_token(IDENTIFIER);
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      default:
                        jj_la1[16] = jj_gen;
                        ;
                      }
                      jj_consume_token(TYPE);
                      jj_consume_token(51);
                      t_class = jj_consume_token(IDENTIFIER);
                      jj_consume_token(52);
                outputstring = "// READ PROMPT: object = " + t_object.image + " name = " + t_class.image + ":" + t_name.image+ "\n";
                execute_code.append(outputstring);

                //outputstring = "\t\tSystem.out.print(" + t_object.image + ");\n";
                //outputstring = "\t\tPrint(" + t_object.image + ");\n";
                //execute_code.append(outputstring);

                if(t_class.image.compareTo("S")==0 || t_class.image.compareTo("s")==0)
                        outputstring = "\t\tString $" + (rules_count+1) + "$" + t_name.image + " = ReadLine(" + t_object.image + ");\n";
                else if(t_class.image.compareTo("D")==0 || t_class.image.compareTo("d")==0)
                        outputstring = "\t\tdouble $" + (rules_count+1) + "$" + t_name.image + " = (new Double(ReadLine(" + t_object.image + "))).doubleValue();\n";
                else if(t_class.image.compareTo("I")==0 || t_class.image.compareTo("i")==0)
                        outputstring = "\t\tint $" + (rules_count+1) + "$" + t_name.image + " = (new Integer(ReadLine(" + t_object.image + "))).intValue();\n";
                else outputstring = "";
                execute_code.append(outputstring);

                if(modeII)
                {
                        outputstring = "\t\tfloat _Certainty_$" + (rules_count+1) + "$" + t_name.image + " = ReadLine_Certainty;\n";
                        execute_code.append(outputstring);
                }
                    } else {
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 50:
                        if (jj_2_5(2)) {
                          jj_consume_token(50);
                          jj_consume_token(BIND);
                          jj_consume_token(VAR);
                          jj_consume_token(51);
                          jj_consume_token(53);
                          t_name = jj_consume_token(IDENTIFIER);
                          s_expr = expr_ia();
                          jj_consume_token(52);
                outputstring = "// BIND: " + t_name.image+ " = " + s_expr + "\n";
                execute_code.append(outputstring);
                outputstring = "\t\t$" + (rules_count+1) + "$" + t_name.image+ " = " + s_expr + ";\n";
                execute_code.append(outputstring);
                        } else {
                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                          case 50:
                            if (jj_2_4(2)) {
                              jj_consume_token(50);
                              jj_consume_token(EXECUTE);
                              t_name = jj_consume_token(IDENTIFIER);
                              jj_consume_token(52);
                outputstring = "// EXECUTE: " + t_name.image + "\n";
                execute_code.append(outputstring);
                outputstring = "\t\tRuntime.getRuntime().exec(\"" + t_name.image + "\");\n";
                execute_code.append(outputstring);
                            } else {
                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                              case 50:
                                jj_consume_token(50);
                                jj_consume_token(DISPLAY);
                                t_name = jj_consume_token(STRING_LITERAL);
                                jj_consume_token(52);
                String[] st;
                st = t_name.image.split("\"");

                outputstring = "// DISPLAY: " + t_name.image + "\n";
                execute_code.append(outputstring);
//NT Win2000	
//		outputstring = "\t\tRuntime.getRuntime().exec(\"cmd /c \\\""+ st[1] +"\\\"\");\n";
                outputstring = "\t\tDisplay(\"" + st[1] + "\");\n";
                execute_code.append(outputstring);
//Win9x
//		outputstring = "Runtime.getRuntime().exec(\"start "+ st[0] +"\");"
//		execute_code.append(outputstring);

                                break;
                              default:
                                jj_la1[17] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                              }
                            }
                            break;
                          default:
                            jj_la1[18] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                          }
                        }
                        break;
                      default:
                        jj_la1[19] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                      }
                    }
                    break;
                  default:
                    jj_la1[20] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                  }
                }
                break;
              default:
                jj_la1[21] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          default:
            jj_la1[22] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

//==============================================================================
  static final public void variableitem(ArrayList vsub_list) throws ParseException {
        String s_subst;
        Token t_iden;
    t_iden = jj_consume_token(IDENTIFIER);
    s_subst = expr_ia();
                vsub_list.add(t_iden.image +"="+ s_subst);
                class_variables_list.add(t_iden.image);
  }

//==============================================================================
  static final public void variableitem2(ArrayList vsub_list) throws ParseException {
        String s_subst;
    s_subst = expr_ia();
                vsub_list.add(s_subst);
  }

//==============================================================================
  static final public String lop() throws ParseException {
        String s_return;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GT:
      jj_consume_token(GT);
             s_return = ">"; {if (true) return s_return;}
      break;
    case GE:
      jj_consume_token(GE);
                s_return = ">="; {if (true) return s_return;}
      break;
    case LT:
      jj_consume_token(LT);
                s_return = "<"; {if (true) return s_return;}
      break;
    case LE:
      jj_consume_token(LE);
                s_return = "<="; {if (true) return s_return;}
      break;
    case EQ:
      jj_consume_token(EQ);
                s_return = "=="; {if (true) return s_return;}
      break;
    case NE:
      jj_consume_token(NE);
               s_return = "!="; {if (true) return s_return;}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String expr() throws ParseException {
        String s_return;
        String s_next = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case 53:
      s_return = basicexpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 56:
      case 57:
      case 58:
      case 59:
        s_next = nextexpr();
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
                if(s_next.length()>0) alias_condition = false;
                {if (true) return s_return + s_next;}
      break;
    case 50:
      jj_consume_token(50);
      s_next = expr();
      jj_consume_token(52);
                {if (true) return "(" + s_next + ")";}
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String nextexpr() throws ParseException {
        String s_next = "";
        String s_aop;
        String s_expr;
        String s_return;
    s_aop = aop();
    s_expr = expr();
    if (jj_2_11(2)) {
      s_next = expr();
    } else {
      ;
    }
                s_return = s_aop + s_expr + s_next;
                {if (true) return s_return;}
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String basicexpr() throws ParseException {
        String basic_here;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      jj_consume_token(FLOATING_POINT_LITERAL);
                //if(variabletype < 2) variabletype = 2;
                //else if(variabletype > 2) variabletype = 99;
                variabletype = variabletype | 2;
                alias_condition = false;
                basic_here = token.image;
                {if (true) return basic_here;}
      break;
    case INTEGER_LITERAL:
      jj_consume_token(INTEGER_LITERAL);
                //if(variabletype < 1) variabletype = 1;
                //else if(variabletype > 2) variabletype = 99;
                variabletype = variabletype | 1;
                alias_condition = false;
                basic_here = token.image;
                {if (true) return basic_here;}
      break;
    case STRING_LITERAL:
      jj_consume_token(STRING_LITERAL);
                //if(variabletype != 3 && variabletype != 0)	variabletype = 99;
                //else variabletype = 3;
                variabletype = variabletype | 4;
                alias_condition = false;
                basic_here = token.image;
                {if (true) return basic_here;}
      break;
    case 53:
      jj_consume_token(53);
      jj_consume_token(IDENTIFIER);
                variabletype = variabletype | 8;
                anyalias_condition = true;
                basic_here = " $" + (rules_count+1) + "$" + token.image + " ";
//		System.out.println("-------------------:" + basic_here + "	 " +slot_list.size());
                {if (true) return basic_here;}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// _ia called from actionstatement()
//==============================================================================
  static final public String expr_ia() throws ParseException {
        String s_return;
        String s_next = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case 53:
      s_return = basicexpr_ia();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 56:
      case 57:
      case 58:
      case 59:
        s_next = nextexpr_ia();
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
                {if (true) return s_return + s_next;}
      break;
    case 50:
      jj_consume_token(50);
      s_next = expr();
      jj_consume_token(52);
                {if (true) return "(" + s_next + ")";}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String nextexpr_ia() throws ParseException {
        String s_next = "";
        String s_aop;
        String s_expr;
        String s_return;
    s_aop = aop();
    s_expr = expr_ia();
    if (jj_2_12(2)) {
      s_next = expr_ia();
    } else {
      ;
    }
                s_return = s_aop + s_expr + s_next;
                {if (true) return s_return;}
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String basicexpr_ia() throws ParseException {
        String basic_here;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      jj_consume_token(FLOATING_POINT_LITERAL);
                basic_here = token.image;
                {if (true) return basic_here;}
      break;
    case INTEGER_LITERAL:
      jj_consume_token(INTEGER_LITERAL);
                basic_here = token.image;
                {if (true) return basic_here;}
      break;
    case STRING_LITERAL:
      jj_consume_token(STRING_LITERAL);
                basic_here = token.image;
                {if (true) return basic_here;}
      break;
    case 53:
      jj_consume_token(53);
      jj_consume_token(IDENTIFIER);
                basic_here = " $" + (rules_count+1) + "$" + token.image + " ";

                if(!aliasname_list.contains(basic_here) &&
                         !aliasnamd_list.contains(basic_here))
                {
                        aliasnamd_list.add(basic_here);
                }

                int indx = aliasname_list.indexOf(basic_here);
                if(indx>=0)
                {
                        basic_here = " token.variable[" + indx + "] ";
                }

                {if (true) return basic_here;}
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String lsno() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
                {if (true) return t.image;}
      break;
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
                {if (true) return t.image;}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String lnno() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
                {if (true) return t.image;}
      break;
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
                {if (true) return t.image;}
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String aop() throws ParseException {
        String s_return;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 56:
      jj_consume_token(56);
            s_return= "+"; {if (true) return s_return;}
      break;
    case 57:
      jj_consume_token(57);
             s_return= "-"; {if (true) return s_return;}
      break;
    case 58:
      jj_consume_token(58);
             s_return= "*"; {if (true) return s_return;}
      break;
    case 59:
      jj_consume_token(59);
             s_return= "/"; {if (true) return s_return;}
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//====	 RUL -> TREE Converter	================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
  static final public ArrayList StartTree() throws ParseException {
        ArrayList at = new ArrayList();
        ArrayList nt_ = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MODULE:
      jj_consume_token(MODULE);
      jj_consume_token(IDENTIFIER);
      jj_consume_token(60);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRUCT:
          ;
          break;
        default:
          jj_la1[34] = jj_gen;
          break label_8;
        }
        structure(at);
      }
      jj_consume_token(61);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 62:
          ;
          break;
        default:
          jj_la1[35] = jj_gen;
          break label_9;
        }
        jj_consume_token(62);
      }
                at.add(0, "\rClasses");
                nt_.add("");
                at.add(nt_);
                {if (true) return at;}
      break;
    case 50:
      label_10:
      while (true) {
        rule_tree(at);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 50:
          ;
          break;
        default:
          jj_la1[36] = jj_gen;
          break label_10;
        }
      }
      jj_consume_token(0);
                at.add(0, "\rRules");
                nt_.add("");
                at.add(nt_);
                {if (true) return at;}
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public void rule_tree(ArrayList at) throws ParseException {
        String s_rulename;
        String s_ruleprior;
        ArrayList nt = new ArrayList();
        ArrayList nti = new ArrayList();
        ArrayList ntt = new ArrayList();
    jj_consume_token(50);
    jj_consume_token(RULE);
    jj_consume_token(51);
    s_rulename = rulename_tree();
    s_ruleprior = ruleprior_tree();
    jj_consume_token(IF);
    condblock_tree(nti);
    jj_consume_token(THEN);
    actblock_tree(nt);
    jj_consume_token(52);
                nti.add(0, "\rIF");
                nt.add(0, s_rulename + " " + s_ruleprior);
                nt.add(1, nti);
                at.add(nt);
  }

//==============================================================================
  static final public void structure(ArrayList at) throws ParseException {
        Token token;
        ArrayList nt = new ArrayList();
        ArrayList nt_ = new ArrayList();
    jj_consume_token(STRUCT);
    token = jj_consume_token(IDENTIFIER);
    jj_consume_token(60);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case LONG:
      case DOUBLE:
      case FLOAT:
        ;
        break;
      default:
        jj_la1[38] = jj_gen;
        break label_11;
      }
      declaration(nt);
    }
    jj_consume_token(61);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 62:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_12;
      }
      jj_consume_token(62);
    }
                nt.add(0, token.image);
                nt_.add("");
                nt.add(nt_);

                at.add(nt);
  }

//==============================================================================
  static final public void declaration(ArrayList at) throws ParseException {
        Token token;
        ArrayList nt = new ArrayList();;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      jj_consume_token(STRING);
      token = jj_consume_token(IDENTIFIER);
      label_13:
      while (true) {
        jj_consume_token(62);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 62:
          ;
          break;
        default:
          jj_la1[40] = jj_gen;
          break label_13;
        }
      }
                nt.add("string " + token.image);
                at.add(nt);
      break;
    case LONG:
      jj_consume_token(LONG);
      token = jj_consume_token(IDENTIFIER);
      label_14:
      while (true) {
        jj_consume_token(62);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 62:
          ;
          break;
        default:
          jj_la1[41] = jj_gen;
          break label_14;
        }
      }
                nt.add("long " + token.image);
                at.add(nt);
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
      token = jj_consume_token(IDENTIFIER);
      label_15:
      while (true) {
        jj_consume_token(62);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 62:
          ;
          break;
        default:
          jj_la1[42] = jj_gen;
          break label_15;
        }
      }
                nt.add("double " + token.image);
                at.add(nt);
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
      token = jj_consume_token(IDENTIFIER);
      label_16:
      while (true) {
        jj_consume_token(62);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 62:
          ;
          break;
        default:
          jj_la1[43] = jj_gen;
          break label_16;
        }
      }

      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//==============================================================================
  static final public String rulename_tree() throws ParseException {
        Token rule_token;
    rule_token = jj_consume_token(IDENTIFIER);
                {if (true) return rule_token.image;}
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String ruleprior_tree() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
                {if (true) return token.image;}
      break;
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
                {if (true) return token.image;}
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public void condblock_tree(ArrayList at) throws ParseException {
        ArrayList nt = new ArrayList();
        ArrayList nnt = new ArrayList();
        ArrayList nnt1 = new ArrayList();
        ArrayList nnt2 = new ArrayList();
        Token slot_token;
    if (jj_2_13(2)) {
      jj_consume_token(50);
      jj_consume_token(CLASS);
      jj_consume_token(51);
      class_token = jj_consume_token(IDENTIFIER);
      jj_consume_token(OBJ);
      jj_consume_token(51);
      jj_consume_token(53);
      obj_token = jj_consume_token(IDENTIFIER);
      slot_ops_tree(nt);
      jj_consume_token(52);
                nt.add(0, "CLASS: " + class_token.image + " OBJ: $" + obj_token.image);
                at.add(nt);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        condblock_tree(nt);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          slot_token = jj_consume_token(OR);
          break;
        case AND:
          slot_token = jj_consume_token(AND);
          break;
        default:
          jj_la1[46] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        condblock_tree(nt);
        jj_consume_token(52);
                nt.add(0, slot_token.image);
                at.add(nt);
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

//==============================================================================
  static final public void slot_ops_tree(ArrayList at) throws ParseException {
        ArrayList nnt = new ArrayList();
//	ArrayList nnt1 = new ArrayList();
//	ArrayList nnt2 = new ArrayList();
        String s_lop;
        String s_expr;
        Token slot_token;
    if (jj_2_14(2)) {
      jj_consume_token(50);
      slot_token = jj_consume_token(IDENTIFIER);
      s_lop = lop();
      s_expr = expr_tree();
      jj_consume_token(52);
                nnt.add(0, slot_token.image + s_lop + s_expr);
                at.add(nnt);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        slot_ops_tree(nnt);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          slot_token = jj_consume_token(OR);
          break;
        case AND:
          slot_token = jj_consume_token(AND);
          break;
        default:
          jj_la1[48] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        slot_ops_tree(nnt);
        jj_consume_token(52);
                nnt.add(0, slot_token.image);
//		nnt.add(nnt);
//		nnt.add(nnt);
                at.add(nnt);
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

//==============================================================================
  static final public void actblock_tree(ArrayList at) throws ParseException {
        ArrayList nt = new ArrayList();
        ArrayList nt_ = new ArrayList();
    jj_consume_token(50);
    label_17:
    while (true) {
      actionstatement_tree(nt);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_17;
      }
    }
    jj_consume_token(52);
                nt.add(0, "\rTHEN");
                nt_.add("");
                nt.add(nt_);
                at.add(nt);
  }

//==============================================================================
  static final public void actionstatement_tree(ArrayList at) throws ParseException {
        Token t_class;
        Token t_object;
        Token t_name;
        String s1, s2;
        String s_expr;
        ArrayList nt = new ArrayList();
        ArrayList nt_ = new ArrayList();
    if (jj_2_22(2)) {
      jj_consume_token(50);
      jj_consume_token(MODIFY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        jj_consume_token(OBJ);
        jj_consume_token(51);
        jj_consume_token(53);
        t_object = jj_consume_token(IDENTIFIER);
        label_18:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            ;
            break;
          default:
            jj_la1[51] = jj_gen;
            break label_18;
          }
          jj_consume_token(50);
          variableitem_tree(nt);
          jj_consume_token(52);
        }
        jj_consume_token(52);
        break;
      case OBJ:
        jj_consume_token(OBJ);
        jj_consume_token(51);
        jj_consume_token(53);
        t_object = jj_consume_token(IDENTIFIER);
        label_19:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            ;
            break;
          default:
            jj_la1[52] = jj_gen;
            break label_19;
          }
          jj_consume_token(50);
          variableitem_tree(nt);
          jj_consume_token(52);
        }
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      s1 = lno_tree();
      s2 = lno_tree();
      jj_consume_token(52);
                nt.add(0, "MODIFY OBJ: $" + t_object.image +" * "+ s1 + " " + s2);
                nt_.add("");
                nt.add(nt_);
                at.add(nt);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        if (jj_2_21(2)) {
          jj_consume_token(50);
          jj_consume_token(MAKE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            jj_consume_token(50);
            jj_consume_token(CLASS);
            jj_consume_token(51);
            t_class = jj_consume_token(IDENTIFIER);
            jj_consume_token(OBJ);
            jj_consume_token(51);
            t_object = jj_consume_token(IDENTIFIER);
            label_20:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                ;
                break;
              default:
                jj_la1[54] = jj_gen;
                break label_20;
              }
              jj_consume_token(50);
              variableitem_tree(nt);
              jj_consume_token(52);
            }
            jj_consume_token(52);
            jj_consume_token(52);
            break;
          case CLASS:
            jj_consume_token(CLASS);
            jj_consume_token(51);
            t_class = jj_consume_token(IDENTIFIER);
            jj_consume_token(OBJ);
            jj_consume_token(51);
            t_object = jj_consume_token(IDENTIFIER);
            label_21:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                ;
                break;
              default:
                jj_la1[55] = jj_gen;
                break label_21;
              }
              jj_consume_token(50);
              variableitem_tree(nt);
              jj_consume_token(52);
            }
            jj_consume_token(52);
            break;
          default:
            jj_la1[56] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                nt.add(0, "MAKE CLASS: " + t_class.image + " OBJ: " + t_object.image);
                nt_.add("");
                nt.add(nt_);
                at.add(nt);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            if (jj_2_20(2)) {
              jj_consume_token(50);
              jj_consume_token(REMOVE);
              jj_consume_token(OBJ);
              jj_consume_token(51);
              jj_consume_token(53);
              t_object = jj_consume_token(IDENTIFIER);
              jj_consume_token(52);
                nt.add(0, "REMOVE OBJ: $" + t_object.image);
                at.add(nt);
            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                if (jj_2_19(2)) {
                  jj_consume_token(50);
                  jj_consume_token(PRINT);
                  s_expr = expr_tree();
                  label_22:
                  while (true) {
                    if (jj_2_15(2)) {
                      ;
                    } else {
                      break label_22;
                    }
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case 54:
                    case 55:
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      case 55:
                        jj_consume_token(55);
                        break;
                      default:
                        jj_la1[57] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                      }
                      break;
                    default:
                      jj_la1[58] = jj_gen;
                      ;
                    }
                    variableitem2_tree(nt);
                  }
                  jj_consume_token(52);
                ArrayList nnt = new ArrayList();

                nnt.add(s_expr);
                nt.add(0, nnt);
                nt.add(0, "PRINT " );
                nt_.add("");
                nt.add(nt_);
                at.add(nt);
                } else {
                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                  case 50:
                    if (jj_2_18(2)) {
                      jj_consume_token(50);
                      jj_consume_token(READ);
                      jj_consume_token(PROMPT);
                      jj_consume_token(51);
                      t_object = jj_consume_token(STRING_LITERAL);
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      default:
                        jj_la1[59] = jj_gen;
                        ;
                      }
                      jj_consume_token(VAR);
                      jj_consume_token(51);
                      jj_consume_token(53);
                      t_name = jj_consume_token(IDENTIFIER);
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      default:
                        jj_la1[60] = jj_gen;
                        ;
                      }
                      jj_consume_token(TYPE);
                      jj_consume_token(51);
                      t_class = jj_consume_token(IDENTIFIER);
                      jj_consume_token(52);
                nt.add(0, "READ PROMPT: " + t_object.image + " VAR: $" + t_name.image + " TYPE: " + t_class.image);
                at.add(nt);
                    } else {
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 50:
                        if (jj_2_17(2)) {
                          jj_consume_token(50);
                          jj_consume_token(BIND);
                          jj_consume_token(VAR);
                          jj_consume_token(51);
                          jj_consume_token(53);
                          t_name = jj_consume_token(IDENTIFIER);
                          s_expr = expr_tree();
                          jj_consume_token(52);
                nt.add(0, "BIND VAR: $" + t_name.image + " " + s_expr);
                at.add(nt);
                        } else {
                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                          case 50:
                            if (jj_2_16(2)) {
                              jj_consume_token(50);
                              jj_consume_token(EXECUTE);
                              t_name = jj_consume_token(IDENTIFIER);
                              jj_consume_token(52);
                nt.add(0, "EXECUTE " + t_name.image);
                at.add(nt);
                            } else {
                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                              case 50:
                                jj_consume_token(50);
                                jj_consume_token(DISPLAY);
                                t_name = jj_consume_token(STRING_LITERAL);
                                jj_consume_token(52);
                nt.add(0, "DISPLAY " + t_name.image);
                at.add(nt);
                                break;
                              default:
                                jj_la1[61] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                              }
                            }
                            break;
                          default:
                            jj_la1[62] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                          }
                        }
                        break;
                      default:
                        jj_la1[63] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                      }
                    }
                    break;
                  default:
                    jj_la1[64] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                  }
                }
                break;
              default:
                jj_la1[65] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          default:
            jj_la1[66] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

//==============================================================================
  static final public void variableitem_tree(ArrayList at) throws ParseException {
        ArrayList nt = new ArrayList();
        String s_subst;
        Token t_iden;
    t_iden = jj_consume_token(IDENTIFIER);
    s_subst = expr_tree();
                nt.add(t_iden.image + " " + s_subst);
                at.add(nt);
  }

//==============================================================================
  static final public void variableitem2_tree(ArrayList at) throws ParseException {
        ArrayList nt = new ArrayList();
        String s_subst;
    s_subst = expr_tree();
                nt.add(s_subst);
                at.add(nt);
  }

//==============================================================================
  static final public String expr_tree() throws ParseException {
        String s_return;
        String s_next = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case 53:
      s_return = basicexpr_tree();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 56:
      case 57:
      case 58:
      case 59:
        s_next = nextexpr_tree();
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
                if(s_next.length()>0) alias_condition = false;
                {if (true) return s_return + s_next;}
      break;
    case 50:
      jj_consume_token(50);
      s_next = expr_tree();
      jj_consume_token(52);
                {if (true) return "(" + s_next + ")";}
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String nextexpr_tree() throws ParseException {
        String s_next = "";
        String s_aop;
        String s_expr;
        String s_return;
    s_aop = aop();
    s_expr = expr_tree();
    if (jj_2_23(2)) {
      s_next = expr_tree();
    } else {
      ;
    }
                s_return = s_aop + s_expr + s_next;
                {if (true) return s_return;}
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String basicexpr_tree() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      jj_consume_token(FLOATING_POINT_LITERAL);
                {if (true) return token.image;}
      break;
    case INTEGER_LITERAL:
      jj_consume_token(INTEGER_LITERAL);
                {if (true) return token.image;}
      break;
    case STRING_LITERAL:
      jj_consume_token(STRING_LITERAL);
                {if (true) return token.image;}
      break;
    case 53:
      jj_consume_token(53);
      jj_consume_token(IDENTIFIER);
                {if (true) return "$" + token.image;}
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public String lno_tree() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      t = jj_consume_token(FLOATING_POINT_LITERAL);
      break;
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//====	 RUL -> CLASS Converter	===============================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
  static final public ArrayList _StartClasses() throws ParseException {
    label_23:
    while (true) {
      rule_class();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[72] = jj_gen;
        break label_23;
      }
    }
    jj_consume_token(0);
                class_variables_list.add(0, "\rClasses");
                // PrintTree(class_variables_list, 0);
                {if (true) return class_variables_list;}
    throw new Error("Missing return statement in function");
  }

//==============================================================================
  static final public void rule_class() throws ParseException {
    jj_consume_token(50);
    jj_consume_token(RULE);
    jj_consume_token(51);
    rulename_class();
    ruleprior_class();
    jj_consume_token(IF);
    condblock_class();
    jj_consume_token(THEN);
    actblock_class();
    jj_consume_token(52);
                classX_objects_list.clear();
                class_objectsX_list.clear();

                variable_type = 0;
//		class_token = null;

  }

//==============================================================================
  static final public void rulename_class() throws ParseException {
    jj_consume_token(IDENTIFIER);

  }

//==============================================================================
  static final public void ruleprior_class() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      jj_consume_token(FLOATING_POINT_LITERAL);

      break;
    case INTEGER_LITERAL:
      jj_consume_token(INTEGER_LITERAL);

      break;
    default:
      jj_la1[73] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//==============================================================================
  static final public void condblock_class() throws ParseException {
        ArrayList nt = new ArrayList();
        Token t_class;
        Token t_object;
    if (jj_2_24(2)) {
      jj_consume_token(50);
      jj_consume_token(CLASS);
      jj_consume_token(51);
      t_class = jj_consume_token(IDENTIFIER);
      jj_consume_token(OBJ);
      jj_consume_token(51);
      jj_consume_token(53);
      t_object = jj_consume_token(IDENTIFIER);
      slot_ops_class(nt);
      jj_consume_token(52);
                InsertVariablesToClasses(t_class.image, variable_type, nt, class_variables_list);

                if(!class_objectsX_list.contains(t_object.image))
                {
                        class_objectsX_list.add(t_object.image);
                        classX_objects_list.add(t_class.image);
                }
                variable_type = 0;
                class_token = null;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        condblock_class();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          jj_consume_token(OR);
          break;
        case AND:
          jj_consume_token(AND);
          break;
        default:
          jj_la1[74] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        condblock_class();
        jj_consume_token(52);

        break;
      default:
        jj_la1[75] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

//==============================================================================
  static final public void slot_ops_class(ArrayList nt) throws ParseException {
        Token tok;
    if (jj_2_25(2)) {
      jj_consume_token(50);
      tok = jj_consume_token(IDENTIFIER);
      lop();
      expr_class();
      jj_consume_token(52);
                if(!nt.contains(tok.image)) nt.add(tok.image);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        slot_ops_class(nt);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          jj_consume_token(OR);
          break;
        case AND:
          jj_consume_token(AND);
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        slot_ops_class(nt);
        jj_consume_token(52);

        break;
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

//==============================================================================
  static final public void actblock_class() throws ParseException {
    jj_consume_token(50);
    label_24:
    while (true) {
      actionstatement_class();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        ;
        break;
      default:
        jj_la1[78] = jj_gen;
        break label_24;
      }
    }
    jj_consume_token(52);

  }

//==============================================================================
  static final public void actionstatement_class() throws ParseException {
        ArrayList nt = new ArrayList();
        Token t_class;
        Token t_object;
    if (jj_2_33(2)) {
      jj_consume_token(50);
      jj_consume_token(MODIFY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        jj_consume_token(50);
        jj_consume_token(OBJ);
        jj_consume_token(51);
        jj_consume_token(53);
        t_object = jj_consume_token(IDENTIFIER);
        label_25:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            ;
            break;
          default:
            jj_la1[79] = jj_gen;
            break label_25;
          }
          jj_consume_token(50);
          variableitem_class(nt);
          jj_consume_token(52);
        }
        jj_consume_token(52);
        break;
      case OBJ:
        jj_consume_token(OBJ);
        jj_consume_token(51);
        jj_consume_token(53);
        t_object = jj_consume_token(IDENTIFIER);
        label_26:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            ;
            break;
          default:
            jj_la1[80] = jj_gen;
            break label_26;
          }
          jj_consume_token(50);
          variableitem_class(nt);
          jj_consume_token(52);
        }
        break;
      default:
        jj_la1[81] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      lno_class();
      lno_class();
      jj_consume_token(52);
                int ind = class_objectsX_list.indexOf(t_object.image);
                if(ind>0)
                        InsertVariablesToClasses(classX_objects_list.get(ind).toString(), variable_type, nt, class_variables_list);
                variable_type = 0;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 50:
        if (jj_2_32(2)) {
          jj_consume_token(50);
          jj_consume_token(MAKE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            jj_consume_token(50);
            jj_consume_token(CLASS);
            jj_consume_token(51);
            t_class = jj_consume_token(IDENTIFIER);
            jj_consume_token(OBJ);
            jj_consume_token(51);
            jj_consume_token(IDENTIFIER);
            label_27:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                ;
                break;
              default:
                jj_la1[82] = jj_gen;
                break label_27;
              }
              jj_consume_token(50);
              variableitem_class(nt);
              jj_consume_token(52);
            }
            jj_consume_token(52);
            jj_consume_token(52);
            break;
          case CLASS:
            jj_consume_token(CLASS);
            jj_consume_token(51);
            t_class = jj_consume_token(IDENTIFIER);
            jj_consume_token(OBJ);
            jj_consume_token(51);
            jj_consume_token(IDENTIFIER);
            label_28:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                ;
                break;
              default:
                jj_la1[83] = jj_gen;
                break label_28;
              }
              jj_consume_token(50);
              variableitem_class(nt);
              jj_consume_token(52);
            }
            jj_consume_token(52);
            break;
          default:
            jj_la1[84] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
                InsertVariablesToClasses(t_class.image, variable_type, nt, class_variables_list);
                variable_type = 0;
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 50:
            if (jj_2_31(2)) {
              jj_consume_token(50);
              jj_consume_token(REMOVE);
              jj_consume_token(OBJ);
              jj_consume_token(51);
              jj_consume_token(53);
              jj_consume_token(IDENTIFIER);
              jj_consume_token(52);

            } else {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case 50:
                if (jj_2_30(2)) {
                  jj_consume_token(50);
                  jj_consume_token(PRINT);
                  expr_tree();
                  label_29:
                  while (true) {
                    if (jj_2_26(2)) {
                      ;
                    } else {
                      break label_29;
                    }
                    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                    case 54:
                    case 55:
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      case 55:
                        jj_consume_token(55);
                        break;
                      default:
                        jj_la1[85] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                      }
                      break;
                    default:
                      jj_la1[86] = jj_gen;
                      ;
                    }
                    variableitem2_class();
                  }
                  jj_consume_token(52);

                } else {
                  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                  case 50:
                    if (jj_2_29(2)) {
                      jj_consume_token(50);
                      jj_consume_token(READ);
                      jj_consume_token(PROMPT);
                      jj_consume_token(51);
                      t_object = jj_consume_token(STRING_LITERAL);
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      default:
                        jj_la1[87] = jj_gen;
                        ;
                      }
                      jj_consume_token(VAR);
                      jj_consume_token(51);
                      jj_consume_token(53);
                      jj_consume_token(IDENTIFIER);
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 54:
                        jj_consume_token(54);
                        break;
                      default:
                        jj_la1[88] = jj_gen;
                        ;
                      }
                      jj_consume_token(TYPE);
                      jj_consume_token(51);
                      jj_consume_token(IDENTIFIER);
                      jj_consume_token(52);

                    } else {
                      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                      case 50:
                        if (jj_2_28(2)) {
                          jj_consume_token(50);
                          jj_consume_token(BIND);
                          jj_consume_token(VAR);
                          jj_consume_token(51);
                          jj_consume_token(53);
                          jj_consume_token(IDENTIFIER);
                          expr_tree();
                          jj_consume_token(52);

                        } else {
                          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                          case 50:
                            if (jj_2_27(2)) {
                              jj_consume_token(50);
                              jj_consume_token(EXECUTE);
                              jj_consume_token(IDENTIFIER);
                              jj_consume_token(52);

                            } else {
                              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                              case 50:
                                jj_consume_token(50);
                                jj_consume_token(DISPLAY);
                                jj_consume_token(STRING_LITERAL);
                                jj_consume_token(52);

                                break;
                              default:
                                jj_la1[89] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                              }
                            }
                            break;
                          default:
                            jj_la1[90] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                          }
                        }
                        break;
                      default:
                        jj_la1[91] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                      }
                    }
                    break;
                  default:
                    jj_la1[92] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
                  }
                }
                break;
              default:
                jj_la1[93] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
            }
            break;
          default:
            jj_la1[94] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

//==============================================================================
  static final public void variableitem_class(ArrayList nt) throws ParseException {
        Token tok;
    tok = jj_consume_token(IDENTIFIER);
    expr_class();
                if(!nt.contains(tok.image)) nt.add(tok.image);
  }

//==============================================================================
  static final public void variableitem2_class() throws ParseException {
    expr_tree();

  }

//==============================================================================
  static final public void expr_class() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case 53:
      basicexpr_class();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 56:
      case 57:
      case 58:
      case 59:
        nextexpr_class();
        break;
      default:
        jj_la1[96] = jj_gen;
        ;
      }

      break;
    case 50:
      jj_consume_token(50);
      expr_class();
      jj_consume_token(52);

      break;
    default:
      jj_la1[97] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//==============================================================================
  static final public void nextexpr_class() throws ParseException {
    aop();
    expr_class();
    if (jj_2_34(2)) {
      expr_class();
    } else {
      ;
    }

  }

//==============================================================================
  static final public void basicexpr_class() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      jj_consume_token(FLOATING_POINT_LITERAL);
                if(variable_type < 2) variable_type = 2;
      break;
    case INTEGER_LITERAL:
      jj_consume_token(INTEGER_LITERAL);
                if(variable_type < 1) variable_type = 1;
      break;
    case STRING_LITERAL:
      jj_consume_token(STRING_LITERAL);
                if(variable_type < 3) variable_type = 3;
      break;
    case 53:
      jj_consume_token(53);
      jj_consume_token(IDENTIFIER);

      break;
    default:
      jj_la1[98] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//==============================================================================
  static final public void lno_class() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      jj_consume_token(FLOATING_POINT_LITERAL);
      break;
    case INTEGER_LITERAL:
      jj_consume_token(INTEGER_LITERAL);
      break;
    default:
      jj_la1[99] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }

  }

  static final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  static final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  static final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  static final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  static final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  static final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }

  static final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }

  static final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_8();
    jj_save(7, xla);
    return retval;
  }

  static final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_9();
    jj_save(8, xla);
    return retval;
  }

  static final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_10();
    jj_save(9, xla);
    return retval;
  }

  static final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_11();
    jj_save(10, xla);
    return retval;
  }

  static final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_12();
    jj_save(11, xla);
    return retval;
  }

  static final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_13();
    jj_save(12, xla);
    return retval;
  }

  static final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_14();
    jj_save(13, xla);
    return retval;
  }

  static final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_15();
    jj_save(14, xla);
    return retval;
  }

  static final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_16();
    jj_save(15, xla);
    return retval;
  }

  static final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_17();
    jj_save(16, xla);
    return retval;
  }

  static final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_18();
    jj_save(17, xla);
    return retval;
  }

  static final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_19();
    jj_save(18, xla);
    return retval;
  }

  static final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_20();
    jj_save(19, xla);
    return retval;
  }

  static final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_21();
    jj_save(20, xla);
    return retval;
  }

  static final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_22();
    jj_save(21, xla);
    return retval;
  }

  static final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_23();
    jj_save(22, xla);
    return retval;
  }

  static final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_24();
    jj_save(23, xla);
    return retval;
  }

  static final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_25();
    jj_save(24, xla);
    return retval;
  }

  static final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_26();
    jj_save(25, xla);
    return retval;
  }

  static final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_27();
    jj_save(26, xla);
    return retval;
  }

  static final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_28();
    jj_save(27, xla);
    return retval;
  }

  static final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_29();
    jj_save(28, xla);
    return retval;
  }

  static final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_30();
    jj_save(29, xla);
    return retval;
  }

  static final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_31();
    jj_save(30, xla);
    return retval;
  }

  static final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_32();
    jj_save(31, xla);
    return retval;
  }

  static final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_33();
    jj_save(32, xla);
    return retval;
  }

  static final private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_34();
    jj_save(33, xla);
    return retval;
  }

  static final private boolean jj_3_31() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(REMOVE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_63() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_23() {
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_32() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MAKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_62() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_75() {
    if (jj_scan_token(53)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_74() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_1() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLASS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_33() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MODIFY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_73() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_55() {
    if (jj_3R_66()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_14() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_66() {
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_72() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_9() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MAKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_59() {
    if (jj_3R_76()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_86() {
    if (jj_scan_token(59)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_85() {
    if (jj_scan_token(58)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_84() {
    if (jj_scan_token(57)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_43() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_83() {
    if (jj_scan_token(56)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_82() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_76() {
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_42() {
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_13() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLASS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_25() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_49() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_48() {
    if (jj_3R_58()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_47() {
    if (jj_scan_token(55)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_24() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLASS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_31() {
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_46() {
    if (jj_scan_token(54)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_35() {
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_35()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_12() {
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_70() {
    if (jj_scan_token(53)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_80() {
    if (jj_scan_token(53)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_79() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_69() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_34() {
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_78() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_68() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_16() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(EXECUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_77() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_67() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_41() {
    if (jj_scan_token(55)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_17() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(BIND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_61() {
    if (jj_3R_81()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_40() {
    if (jj_scan_token(54)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_81() {
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_57() {
    if (jj_3R_71()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_18() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(READ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_4() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(EXECUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_51() {
    if (jj_scan_token(55)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_71() {
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_53() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_5() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(BIND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_2() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_50() {
    if (jj_scan_token(54)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_19() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(PRINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_52() {
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_61()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_20() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(REMOVE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_45() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_38() {
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_38()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_44() {
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_21() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MAKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_6() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(READ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_10() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MODIFY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_22() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MODIFY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_27() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(EXECUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_65() {
    if (jj_scan_token(53)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_28() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(BIND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_7() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(PRINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_29() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(READ)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3R_64() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_30() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(PRINT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_8() {
    if (jj_scan_token(50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(REMOVE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static final private boolean jj_3_11() {
    if (jj_3R_32()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  static private boolean jj_initialized_once = false;
  static public RuleParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static public boolean lookingAhead = false;
  static private boolean jj_semLA;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[100];
  static final private int[] jj_la1_0 = {0x0,0x0,0x6000000,0x0,0x6000000,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000000,0x0,0x6000000,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000000,0x0,0x6000000,0x0,0x0,0x0,0x0,0x400,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  static final private int[] jj_la1_1 = {0x40000,0x4400,0x0,0x40000,0x0,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0xc00000,0xc00000,0x400000,0x400000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x1,0xf000000,0x264400,0x224400,0xf000000,0x264400,0x224400,0x4400,0x4400,0xf000000,0x4,0x40000000,0x40000,0x40002,0x78,0x40000000,0x40000000,0x40000000,0x40000000,0x40000000,0x78,0x4400,0x0,0x40000,0x0,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0xc00000,0xc00000,0x400000,0x400000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0xf000000,0x264400,0x224400,0x4400,0x40000,0x4400,0x0,0x40000,0x0,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0xc00000,0xc00000,0x400000,0x400000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0x40000,0xf000000,0x264400,0x224400,0x4400,};
  static final private JJCalls[] jj_2_rtns = new JJCalls[34];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  public RuleParser(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new RuleParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 100; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 100; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public RuleParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new RuleParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 100; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 100; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public RuleParser(RuleParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 100; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(RuleParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 100; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {
        int[] oldentry = (int[])(enum.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  static final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[63];
    for (int i = 0; i < 63; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 100; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 63; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

  static final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 34; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  static final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
